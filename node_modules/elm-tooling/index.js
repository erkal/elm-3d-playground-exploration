#!/usr/bin/env node
'use strict';

var Install = require('./Install.js');
var fs = require('fs');
var path = require('path');
var readline = require('readline');

function help(cwd, env) {
    return `
${Install.bold("elm-tooling init")}
    Create a sample elm-tooling.json in the current directory

${Install.bold("elm-tooling tools")}
    Add, remove and update tools

${Install.bold("elm-tooling install")}
    Download the tools in the closest elm-tooling.json to:
    ${Install.dim(Install.getElmToolingInstallPath(cwd, env).absolutePath)}
    And create links to them in node_modules/.bin/

${Install.bold("npx elm --help")}
    Example on how to run installed tools

${Install.dim("---")}

${Install.bold("Environment variables:")}
    ${Install.bold("ELM_HOME")}
        Customize where tools will be downloaded
        (The Elm compiler uses this variable too for where to store packages.)

    ${Install.bold("NO_ELM_TOOLING_INSTALL")}
        Disable the install command

    ${Install.bold("NO_COLOR")}
        Disable colored output

${Install.bold("Documentation:")}
    https://elm-tooling.github.io/elm-tooling-cli/cli

${Install.bold("Version:")}
    1.14.0
`.trim();
}

const DEFAULT_TOOLS = [
    "elm",
    "elm-format",
    "elm-json",
];
DEFAULT_TOOLS.sort((a, b) => a.localeCompare(b));
function init(cwd, env, logger) {
    var _a;
    const elmToolingJsonPath = {
        tag: "ElmToolingJsonPath",
        theElmToolingJsonPath: Install.absolutePathFromString(cwd.path, "elm-tooling.json"),
    };
    if (fs.existsSync(elmToolingJsonPath.theElmToolingJsonPath.absolutePath)) {
        logger.error(Install.bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
        logger.error("Already exists!");
        return 1;
    }
    const tools = (_a = tryGuessToolsFromNodeModules(cwd, env)) !== null && _a !== void 0 ? _a : Install.fromEntries(DEFAULT_TOOLS.map((name) => [name, Install.getLastVersion(name)]));
    const elmVersionFromElmJson = getElmVersionFromElmJson(cwd);
    const json = {
        tools: elmVersionFromElmJson === undefined
            ? tools
            : { ...tools, elm: elmVersionFromElmJson },
    };
    fs.writeFileSync(elmToolingJsonPath.theElmToolingJsonPath.absolutePath, Install.toJSON(json));
    logger.log(Install.bold(elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
    logger.log("Created! Open it in a text editor and have a look!");
    logger.log("To install tools: elm-tooling install");
    return 0;
}
function tryGetElmJson(cwd) {
    const elmJsonPath = {
        tag: "ElmJsonPath",
        theElmJsonPath: Install.absolutePathFromString(cwd.path, "elm.json"),
    };
    const elmJson = JSON.parse(fs.readFileSync(elmJsonPath.theElmJsonPath.absolutePath, "utf8"));
    if (!Install.isRecord(elmJson)) {
        throw new Error(`Expected elm.json to be a JSON object but got: ${JSON.stringify(elmJson)}`);
    }
    return { elmJsonPath, elmJson };
}
function tryGuessToolsFromNodeModules(cwd, env) {
    const nodeModulesPath = Install.findClosest("node_modules", cwd.path);
    // istanbul ignore if
    if (nodeModulesPath === undefined) {
        return undefined;
    }
    const pairs = Install.flatMap(Object.entries(Install.KNOWN_TOOLS), ([name, versions]) => {
        try {
            const pkgPath = Install.absolutePathFromString(nodeModulesPath, path.join(name, "package.json"));
            const pkg = JSON.parse(fs.readFileSync(pkgPath.absolutePath, "utf8"));
            const version = Install.isRecord(pkg) && typeof pkg.version === "string"
                ? pkg.version
                : undefined;
            if (version === undefined) {
                return [];
            }
            // Exact version match.
            if (Object.hasOwnProperty.call(versions, version)) {
                return [[name, version]];
            }
            // Support for example 0.19.1-3 -> 0.19.1.
            const alternateVersion = Install.split(version, /[+-]/)[0];
            if (Object.hasOwnProperty.call(versions, alternateVersion)) {
                return [[name, alternateVersion]];
            }
            // If we find for example elm-json@0.2.7 in node_modules, try to find a
            // supported semver-matching elm-json version such as 0.2.8.
            const tool = Install.getToolThrowing({
                name,
                version: `^${version}`,
                cwd,
                env,
            });
            return [[tool.name, tool.version]];
        }
        catch (_a) {
            return [];
        }
    });
    return Install.isNonEmptyArray(pairs) ? Install.fromEntries(pairs) : undefined;
}
function getElmVersionFromElmJson(cwd) {
    try {
        return getElmVersionFromElmJsonHelper(cwd);
    }
    catch (_a) {
        return undefined;
    }
}
const elmVersionRangeRegex = /^\s*(\S+)\s*<=\s*v\s*<\s*(\S+)\s*$/;
function getElmVersionFromElmJsonHelper(cwd) {
    const { elmJson } = tryGetElmJson(cwd);
    const elmVersion = elmJson["elm-version"];
    if (typeof elmVersion !== "string") {
        throw new Error(`Expected "elm-version" to be a string but got: ${JSON.stringify(elmVersion)}`);
    }
    switch (elmJson.type) {
        case "application":
            if (!Object.hasOwnProperty.call(Install.KNOWN_TOOLS.elm, elmVersion)) {
                throw new Error(`Unknown/unsupported Elm version: ${elmVersion}`);
            }
            return elmVersion;
        case "package": {
            const match = elmVersionRangeRegex.exec(elmVersion);
            if (match === null) {
                throw new Error(`Elm version range did not match the regex: ${elmVersion}`);
            }
            const [, lowerBoundInclusive, upperBoundExclusive] = match;
            const version = Install.getLatestVersionInRange(
            // `lowerBoundInclusive` and `upperBoundExclusive` are always matched in
            // the regex, but TypeScript doesnâ€™t know that.
            lowerBoundInclusive, upperBoundExclusive, Object.keys(Install.KNOWN_TOOLS.elm).reverse());
            if (version === undefined) {
                throw new Error(`No version found for: ${elmVersion}`);
            }
            return version;
        }
        default:
            throw new Error(`Expected "type" to be "application" or "package" but got: ${JSON.stringify(elmJson.type)}`);
    }
}

async function toolsCommand(cwd, env, logger, stdin, stdout) {
    if (!stdin.isTTY) {
        logger.error("This command requires stdin to be a TTY.");
        return 1;
    }
    const parseResult = Install.findReadAndParseElmToolingJson(cwd, env);
    switch (parseResult.tag) {
        case "ElmToolingJsonNotFound":
            logger.error(parseResult.message);
            return 1;
        case "ReadAsJsonObjectError":
            logger.error(Install.bold(parseResult.elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
            logger.error("");
            logger.error(Install.printParseErrors(parseResult.errors));
            return 1;
        case "Parsed": {
            const save = (tools) => {
                updateElmToolingJson(parseResult.elmToolingJsonPath, parseResult.originalObject, tools);
            };
            const allTools = parseResult.tools === undefined
                ? []
                : sortTools([
                    ...parseResult.tools.existing,
                    ...parseResult.tools.missing,
                    ...parseResult.tools.unsupported,
                ]);
            logger.log(Install.bold(parseResult.elmToolingJsonPath.theElmToolingJsonPath.absolutePath));
            return start(logger, stdin, stdout, allTools, save);
        }
    }
}
async function start(logger, stdin, stdout, tools, save) {
    return new Promise((resolve) => {
        let state = {
            tools,
            cursorTool: Install.isNonEmptyArray(tools) ? tools[0] : getDefaultCursorTool(),
        };
        let cursor = { x: 0, y: 0 };
        const redraw = ({ moveCursor }) => {
            // Temporarily hide cursor to avoid seeing it briefly jump around on Windows.
            stdout.write(Install.HIDE_CURSOR);
            readline.moveCursor(stdout, -cursor.x, -cursor.y);
            const content = logger.handleColor(`${draw(state.tools)}\n\n${instructions}\n`);
            stdout.write(content);
            const y = getCursorLine(state.cursorTool);
            cursor = { x: 3, y };
            if (moveCursor) {
                readline.moveCursor(stdout, cursor.x, -(content.split("\n").length - 1 - cursor.y));
            }
            stdout.write(Install.SHOW_CURSOR);
        };
        logger.log("");
        redraw({ moveCursor: true });
        stdin.setRawMode(true);
        stdin.resume();
        stdin.on("data", (buffer) => {
            const [nextState, cmd] = update(buffer.toString(), state);
            state = nextState;
            switch (cmd) {
                case "None":
                    redraw({ moveCursor: true });
                    break;
                case "Exit":
                    redraw({ moveCursor: false });
                    logger.log("");
                    logger.log("Nothing changed.");
                    resolve(0);
                    break;
                case "Save":
                    redraw({ moveCursor: false });
                    logger.log("");
                    if (toolsEqual(tools, state.tools)) {
                        logger.log("Nothing changed.");
                    }
                    else {
                        try {
                            save(state.tools);
                        }
                        catch (unknownError) {
                            const error = Install.toError(unknownError);
                            logger.error(`Failed to save: ${error.message}`);
                            resolve(1);
                            break;
                        }
                        const verb = toolHasBeenAdded(tools, state.tools)
                            ? "install"
                            : "unlink";
                        logger.log(`Saved! To ${verb}: elm-tooling install`);
                    }
                    resolve(0);
                    break;
                case "TestExit":
                    redraw({ moveCursor: true });
                    resolve(0);
                    break;
            }
        });
    }).finally(() => {
        stdin.pause();
    });
}
function draw(tools) {
    return Install.join(Object.entries(Install.KNOWN_TOOLS).map(([name, versionObjects]) => {
        const versions = Object.keys(versionObjects);
        const selectedIndex = versions.findIndex((version) => tools.some((tool) => tool.name === name && tool.version === version));
        const versionsString = Install.join(versions.map((version, index) => {
            const marker = index === selectedIndex ? Install.bold("x") : " ";
            return `  ${Install.dim("[")}${marker}${Install.dim("]")} ${index === selectedIndex ? version : Install.dim(version)}`;
        }), "\n");
        return `${Install.bold(name)}\n${versionsString}`;
    }), "\n\n");
}
const instructions = `
${Install.bold("Up")}/${Install.bold("Down")} to move
${Install.bold("Space")} to toggle
${Install.bold("Enter")} to save
`.trim();
function getCursorLine(cursorTool) {
    const names = Install.KNOWN_TOOL_NAMES;
    const nameIndex = names.indexOf(cursorTool.name);
    // istanbul ignore if
    if (nameIndex === -1) {
        return 1;
    }
    const name = names[nameIndex];
    const versions = Object.keys(Install.KNOWN_TOOLS[name]);
    const versionIndex = versions.indexOf(cursorTool.version);
    // istanbul ignore if
    if (versionIndex === -1) {
        return 1;
    }
    return (1 +
        2 * nameIndex +
        versionIndex +
        names
            .slice(0, nameIndex)
            .reduce((sum, name2) => sum + Object.keys(Install.KNOWN_TOOLS[name2]).length, 0));
}
function getDefaultCursorTool() {
    const [name] = Install.KNOWN_TOOL_NAMES;
    return { name, version: Install.getLastVersion(name) };
}
function update(keypress, state) {
    switch (keypress) {
        case "\x03": // ctrl+c
        case "q":
            return [state, "Exit"];
        case "\x1B[A": // up
        case "k":
            return [
                { ...state, cursorTool: updateCursorTool(-1, state.cursorTool) },
                "None",
            ];
        case "\x1B[B": // down
        case "j":
            return [
                { ...state, cursorTool: updateCursorTool(1, state.cursorTool) },
                "None",
            ];
        case "\r": // enter
            return [state, "Save"];
        case " ": // space
        case "x":
        case "o":
            return [
                { ...state, tools: toggleTool(state.cursorTool, state.tools) },
                "None",
            ];
        case "test-exit":
            return [state, "TestExit"];
        default:
            return [state, "None"];
    }
}
function updateCursorTool(delta, cursorTool) {
    const all = Install.flatMap(Object.entries(Install.KNOWN_TOOLS), ([name, versions]) => Object.keys(versions).map((version) => ({ name, version })));
    const index = all.findIndex((tool) => tool.name === cursorTool.name && tool.version === cursorTool.version);
    // istanbul ignore if
    if (index === -1) {
        return cursorTool;
    }
    const nextIndex = index + delta;
    return nextIndex < 0 || nextIndex >= all.length
        ? cursorTool
        : all[nextIndex];
}
function toggleTool(cursorTool, tools) {
    const isSelected = tools.some((tool) => tool.name === cursorTool.name && tool.version === cursorTool.version);
    const filtered = tools.filter((tool) => tool.name !== cursorTool.name);
    return isSelected ? filtered : [...filtered, cursorTool];
}
function updateElmToolingJson(elmToolingJsonPath, originalObject, toolsList) {
    const tools = Install.isNonEmptyArray(toolsList)
        ? Install.fromEntries(sortTools(toolsList).map(({ name, version }) => [name, version]))
        : undefined;
    fs.writeFileSync(elmToolingJsonPath.theElmToolingJsonPath.absolutePath, Install.toJSON({ ...originalObject, tools }));
}
function sortTools(tools) {
    return tools.slice().sort((a, b) => a.name.localeCompare(b.name));
}
function toolsEqual(a, b) {
    return (a.length === b.length &&
        a.every((toolA) => b.some((toolB) => toolA.name === toolB.name && toolA.version === toolB.version)));
}
function toolHasBeenAdded(before, after) {
    return after.some((toolA) => !before.some((toolB) => toolA.name === toolB.name && toolA.version === toolB.version));
}

function makeLogger({ env, stdout, stderr, }) {
    const NO_COLOR = "NO_COLOR" in env;
    const handleColor = (string) => NO_COLOR ? Install.removeColor(string) : string;
    return {
        handleColor,
        log(message) {
            stdout.write(`${handleColor(message)}\n`);
        },
        error(message) {
            stderr.write(`${handleColor(message)}\n`);
        },
        raw: {
            NO_COLOR,
            stdout,
            stderr,
        },
    };
}

async function elmToolingCli(args, 
// istanbul ignore next
{ cwd: cwdString = process.cwd(), env = process.env, stdin = process.stdin, stdout = process.stdout, stderr = process.stderr, } = {}) {
    const logger = makeLogger({ env, stdout, stderr });
    const cwd = {
        tag: "Cwd",
        path: Install.absolutePathFromString({ tag: "AbsolutePath", absolutePath: process.cwd() }, cwdString),
    };
    const isHelp = args.some((arg) => arg === "-h" || arg === "-help" || arg === "--help");
    if (isHelp) {
        logger.log(help(cwd, env));
        return 0;
    }
    // So far no command takes any further arguments.
    // Let each command handle this when needed.
    if (args.length > 1) {
        logger.error(`Expected a single argument but got: ${Install.join(args.slice(1), " ")}`);
        return 1;
    }
    switch (args[0]) {
        case undefined:
        case "help":
            logger.log(help(cwd, env));
            return 0;
        case "init":
            return init(cwd, env, logger);
        case "validate":
            logger.log("The `validate` command no longer exists.");
            logger.log('If you have "entrypoints" you can remove that field.');
            logger.log('To validate "tools": elm-tooling install');
            return 0;
        case "install":
            return Install.install(cwd, env, logger);
        case "tools":
            return toolsCommand(cwd, env, logger, stdin, stdout);
        default:
            logger.error(`Unknown command: ${args[0]}`);
            return 1;
    }
}
// istanbul ignore if
if (require.main === module) {
    elmToolingCli(process.argv.slice(2))
        .then((exitCode) => {
        process.exitCode = exitCode;
    })
        .catch((error) => {
        var _a;
        process.stderr.write(`Unexpected error:\n${(_a = error.stack) !== null && _a !== void 0 ? _a : error.message}\n`);
        process.exitCode = 1;
    });
}

module.exports = elmToolingCli;
