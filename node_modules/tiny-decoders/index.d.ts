export declare type Decoder<T, U = unknown> = (value: U) => T;
declare type WithUndefinedAsOptional<T> = T extends Record<string, unknown> ? Expand<{
    [P in OptionalKeys<T>]?: T[P];
} & {
    [P in RequiredKeys<T>]: T[P];
}> : T;
declare type RequiredKeys<T> = {
    [P in keyof T]: undefined extends T[P] ? never : P;
}[keyof T];
declare type OptionalKeys<T> = {
    [P in keyof T]: undefined extends T[P] ? P : never;
}[keyof T];
declare type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export declare function boolean(value: unknown): boolean;
export declare function number(value: unknown): number;
export declare function string(value: unknown): string;
export declare function stringUnion<T extends Record<string, unknown>>(mapping: keyof T extends string ? keyof T extends never ? "stringUnion must have at least one key" : T : {
    [P in keyof T]: P extends number ? ["stringUnion keys must be strings, not numbers", never] : T[P];
}): Decoder<keyof T>;
export declare function array<T>(decoder: Decoder<T>): Decoder<Array<T>>;
export declare function record<T>(decoder: Decoder<T>): Decoder<Record<string, T>>;
export declare function fields<T>(callback: (field: <U>(key: string, decoder: Decoder<U>) => U, object: Record<string, unknown>) => T, { exact, allow, }?: {
    exact?: "allow extra" | "throw";
    allow?: "array" | "object";
}): Decoder<WithUndefinedAsOptional<T>>;
export declare function fieldsAuto<T extends Record<string, unknown>>(mapping: {
    [P in keyof T]: P extends "__proto__" ? never : Decoder<T[P]>;
}, { exact }?: {
    exact?: "allow extra" | "throw";
}): Decoder<WithUndefinedAsOptional<T>>;
declare type Values<T> = T[keyof T];
export declare function fieldsUnion<T extends Record<string, Decoder<unknown>>>(key: string, mapping: keyof T extends string ? keyof T extends never ? "fieldsUnion must have at least one member" : T : {
    [P in keyof T]: P extends number ? "fieldsUnion keys must be strings, not numbers" : T[P];
}): Decoder<Expand<Values<{
    [P in keyof T]: T[P] extends Decoder<infer U, infer _> ? U : never;
}>>>;
export declare function tuple<T extends ReadonlyArray<unknown>>(mapping: readonly [...{
    [P in keyof T]: Decoder<T[P]>;
}]): Decoder<[...T]>;
export declare function multi<T1 = never, T2 = never, T3 = never, T4 = never, T5 = never, T6 = never, T7 = never>(mapping: {
    undefined?: Decoder<T1, undefined>;
    null?: Decoder<T2, null>;
    boolean?: Decoder<T3, boolean>;
    number?: Decoder<T4, number>;
    string?: Decoder<T5, string>;
    array?: Decoder<T6, Array<unknown>>;
    object?: Decoder<T7, Record<string, unknown>>;
}): Decoder<T1 | T2 | T3 | T4 | T5 | T6 | T7>;
export declare function optional<T>(decoder: Decoder<T>): Decoder<T | undefined>;
export declare function optional<T, U>(decoder: Decoder<T>, defaultValue: U): Decoder<T | U>;
export declare function nullable<T>(decoder: Decoder<T>): Decoder<T | null>;
export declare function nullable<T, U>(decoder: Decoder<T>, defaultValue: U): Decoder<T | U>;
export declare function chain<T, U>(decoder: Decoder<T>, next: Decoder<U, T>): Decoder<U>;
export declare type DecoderErrorVariant = {
    tag: "custom";
    message: string;
    got: unknown;
} | {
    tag: "exact fields";
    knownFields: Array<string>;
    got: Array<string>;
} | {
    tag: "tuple size";
    expected: number;
    got: number;
} | {
    tag: "unknown fieldsUnion tag";
    knownTags: Array<string>;
    got: string;
} | {
    tag: "unknown multi type";
    knownTypes: Array<"array" | "boolean" | "null" | "number" | "object" | "string" | "undefined">;
    got: unknown;
} | {
    tag: "unknown stringUnion variant";
    knownVariants: Array<string>;
    got: string;
} | {
    tag: "array";
    got: unknown;
} | {
    tag: "boolean";
    got: unknown;
} | {
    tag: "number";
    got: unknown;
} | {
    tag: "object";
    got: unknown;
} | {
    tag: "string";
    got: unknown;
};
declare type Key = number | string;
export declare class DecoderError extends TypeError {
    path: Array<Key>;
    variant: DecoderErrorVariant;
    nullable: boolean;
    optional: boolean;
    constructor({ key, ...params }: {
        message: string;
        value: unknown;
        key?: Key;
    } | (DecoderErrorVariant & {
        key?: Key;
    }));
    static MISSING_VALUE: symbol;
    static at(error: unknown, key?: Key): DecoderError;
    format(options?: ReprOptions): string;
}
export declare type ReprOptions = {
    recurse?: boolean;
    maxArrayChildren?: number;
    maxObjectChildren?: number;
    maxLength?: number;
    recurseMaxLength?: number;
    sensitive?: boolean;
};
export declare function repr(value: unknown, { recurse, maxArrayChildren, maxObjectChildren, maxLength, recurseMaxLength, sensitive, }?: ReprOptions): string;
export {};
