export function boolean(value) {
    if (typeof value !== "boolean") {
        throw new DecoderError({ tag: "boolean", got: value });
    }
    return value;
}
export function number(value) {
    if (typeof value !== "number") {
        throw new DecoderError({ tag: "number", got: value });
    }
    return value;
}
export function string(value) {
    if (typeof value !== "string") {
        throw new DecoderError({ tag: "string", got: value });
    }
    return value;
}
export function stringUnion(mapping) {
    return function stringUnionDecoder(value) {
        const str = string(value);
        if (!Object.prototype.hasOwnProperty.call(mapping, str)) {
            throw new DecoderError({
                tag: "unknown stringUnion variant",
                knownVariants: Object.keys(mapping),
                got: str,
            });
        }
        return str;
    };
}
function unknownArray(value) {
    if (!Array.isArray(value)) {
        throw new DecoderError({ tag: "array", got: value });
    }
    return value;
}
function unknownRecord(value) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new DecoderError({ tag: "object", got: value });
    }
    return value;
}
export function array(decoder) {
    return function arrayDecoder(value) {
        const arr = unknownArray(value);
        const result = [];
        for (let index = 0; index < arr.length; index++) {
            try {
                result.push(decoder(arr[index]));
            }
            catch (error) {
                throw DecoderError.at(error, index);
            }
        }
        return result;
    };
}
export function record(decoder) {
    return function recordDecoder(value) {
        const object = unknownRecord(value);
        const keys = Object.keys(object);
        const result = {};
        for (const key of keys) {
            if (key === "__proto__") {
                continue;
            }
            try {
                result[key] = decoder(object[key]);
            }
            catch (error) {
                throw DecoderError.at(error, key);
            }
        }
        return result;
    };
}
export function fields(callback, { exact = "allow extra", allow = "object", } = {}) {
    return function fieldsDecoder(value) {
        const object = allow === "array"
            ? unknownArray(value)
            : unknownRecord(value);
        const knownFields = Object.create(null);
        function field(key, decoder) {
            try {
                const result = decoder(object[key]);
                knownFields[key] = null;
                return result;
            }
            catch (error) {
                throw DecoderError.at(error, key);
            }
        }
        const result = callback(field, object);
        if (exact !== "allow extra") {
            const unknownFields = Object.keys(object).filter((key) => !Object.prototype.hasOwnProperty.call(knownFields, key));
            if (unknownFields.length > 0) {
                throw new DecoderError({
                    tag: "exact fields",
                    knownFields: Object.keys(knownFields),
                    got: unknownFields,
                });
            }
        }
        return result;
    };
}
export function fieldsAuto(mapping, { exact = "allow extra" } = {}) {
    return function fieldsAutoDecoder(value) {
        const object = unknownRecord(value);
        const keys = Object.keys(mapping);
        const result = {};
        for (const key of keys) {
            if (key === "__proto__") {
                continue;
            }
            const decoder = mapping[key];
            try {
                result[key] = decoder(object[key]);
            }
            catch (error) {
                throw DecoderError.at(error, key);
            }
        }
        if (exact !== "allow extra") {
            const unknownFields = Object.keys(object).filter((key) => !Object.prototype.hasOwnProperty.call(mapping, key));
            if (unknownFields.length > 0) {
                throw new DecoderError({
                    tag: "exact fields",
                    knownFields: keys,
                    got: unknownFields,
                });
            }
        }
        return result;
    };
}
export function fieldsUnion(key, mapping) {
    // eslint-disable-next-line prefer-arrow-callback
    return fields(function fieldsUnionFields(field, object) {
        const tag = field(key, string);
        if (Object.prototype.hasOwnProperty.call(mapping, tag)) {
            const decoder = mapping[tag];
            return decoder(object);
        }
        throw new DecoderError({
            tag: "unknown fieldsUnion tag",
            knownTags: Object.keys(mapping),
            got: tag,
            key,
        });
    });
}
export function tuple(mapping) {
    return function tupleDecoder(value) {
        const arr = unknownArray(value);
        if (arr.length !== mapping.length) {
            throw new DecoderError({
                tag: "tuple size",
                expected: mapping.length,
                got: arr.length,
            });
        }
        const result = [];
        for (let index = 0; index < arr.length; index++) {
            try {
                const decoder = mapping[index];
                result.push(decoder(arr[index]));
            }
            catch (error) {
                throw DecoderError.at(error, index);
            }
        }
        return result;
    };
}
export function multi(mapping) {
    return function multiDecoder(value) {
        if (value === undefined) {
            if (mapping.undefined !== undefined) {
                return mapping.undefined(value);
            }
        }
        else if (value === null) {
            if (mapping.null !== undefined) {
                return mapping.null(value);
            }
        }
        else if (typeof value === "boolean") {
            if (mapping.boolean !== undefined) {
                return mapping.boolean(value);
            }
        }
        else if (typeof value === "number") {
            if (mapping.number !== undefined) {
                return mapping.number(value);
            }
        }
        else if (typeof value === "string") {
            if (mapping.string !== undefined) {
                return mapping.string(value);
            }
        }
        else if (Array.isArray(value)) {
            if (mapping.array !== undefined) {
                return mapping.array(value);
            }
        }
        else {
            if (mapping.object !== undefined) {
                return mapping.object(value);
            }
        }
        throw new DecoderError({
            tag: "unknown multi type",
            knownTypes: Object.keys(mapping),
            got: value,
        });
    };
}
export function optional(decoder, defaultValue) {
    return function optionalDecoder(value) {
        if (value === undefined) {
            return defaultValue;
        }
        try {
            return decoder(value);
        }
        catch (error) {
            const newError = DecoderError.at(error);
            if (newError.path.length === 0) {
                newError.optional = true;
            }
            throw newError;
        }
    };
}
export function nullable(decoder, ...rest) {
    const defaultValue = rest.length === 0 ? null : rest[0];
    return function nullableDecoder(value) {
        if (value === null) {
            return defaultValue;
        }
        try {
            return decoder(value);
        }
        catch (error) {
            const newError = DecoderError.at(error);
            if (newError.path.length === 0) {
                newError.nullable = true;
            }
            throw newError;
        }
    };
}
export function chain(decoder, next) {
    return function chainDecoder(value) {
        return next(decoder(value));
    };
}
function formatDecoderErrorVariant(variant, options) {
    const formatGot = (value) => {
        const formatted = repr(value, options);
        return (options === null || options === void 0 ? void 0 : options.sensitive) === true
            ? `${formatted}\n(Actual values are hidden in sensitive mode.)`
            : formatted;
    };
    const stringList = (strings) => strings.length === 0
        ? "(none)"
        : strings.map((s) => JSON.stringify(s)).join(", ");
    const got = (message, value) => value === DecoderError.MISSING_VALUE
        ? message
        : `${message}\nGot: ${formatGot(value)}`;
    switch (variant.tag) {
        case "boolean":
        case "number":
        case "string":
            return got(`Expected a ${variant.tag}`, variant.got);
        case "array":
        case "object":
            return got(`Expected an ${variant.tag}`, variant.got);
        case "unknown multi type":
            return `Expected one of these types: ${variant.knownTypes.length === 0
                ? "never"
                : variant.knownTypes.join(", ")}\nGot: ${formatGot(variant.got)}`;
        case "unknown fieldsUnion tag":
            return `Expected one of these tags: ${stringList(variant.knownTags)}\nGot: ${formatGot(variant.got)}`;
        case "unknown stringUnion variant":
            return `Expected one of these variants: ${stringList(variant.knownVariants)}\nGot: ${formatGot(variant.got)}`;
        case "exact fields":
            return `Expected only these fields: ${stringList(variant.knownFields)}\nFound extra fields: ${formatGot(variant.got).replace(/^\[|\]$/g, "")}`;
        case "tuple size":
            return `Expected ${variant.expected} items\nGot: ${variant.got}`;
        case "custom":
            return got(variant.message, variant.got);
    }
}
export class DecoderError extends TypeError {
    constructor({ key, ...params }) {
        const variant = "tag" in params
            ? params
            : { tag: "custom", message: params.message, got: params.value };
        super(`${formatDecoderErrorVariant(variant, 
        // Default to sensitive so accidental uncaught errors don’t leak
        // anything. Explicit `.format()` defaults to non-sensitive.
        { sensitive: true })}\n\nFor better error messages, see https://github.com/lydell/tiny-decoders#error-messages`);
        this.path = key === undefined ? [] : [key];
        this.variant = variant;
        this.nullable = false;
        this.optional = false;
    }
    static at(error, key) {
        if (error instanceof DecoderError) {
            if (key !== undefined) {
                error.path.unshift(key);
            }
            return error;
        }
        return new DecoderError({
            tag: "custom",
            message: error instanceof Error ? error.message : String(error),
            got: DecoderError.MISSING_VALUE,
            key,
        });
    }
    format(options) {
        const path = this.path.map((part) => `[${JSON.stringify(part)}]`).join("");
        const nullableString = this.nullable ? " (nullable)" : "";
        const optionalString = this.optional ? " (optional)" : "";
        const variant = formatDecoderErrorVariant(this.variant, options);
        return `At root${path}${nullableString}${optionalString}:\n${variant}`;
    }
}
DecoderError.MISSING_VALUE = Symbol("DecoderError.MISSING_VALUE");
export function repr(value, { recurse = true, maxArrayChildren = 5, maxObjectChildren = 3, maxLength = 100, recurseMaxLength = 20, sensitive = false, } = {}) {
    const type = typeof value;
    const toStringType = Object.prototype.toString
        .call(value)
        .replace(/^\[object\s+(.+)\]$/, "$1");
    try {
        if (value == null ||
            type === "number" ||
            type === "boolean" ||
            type === "symbol" ||
            toStringType === "RegExp") {
            return sensitive
                ? toStringType.toLowerCase()
                : truncate(String(value), maxLength);
        }
        if (type === "string") {
            return sensitive ? type : truncate(JSON.stringify(value), maxLength);
        }
        if (typeof value === "function") {
            return `function ${truncate(JSON.stringify(value.name), maxLength)}`;
        }
        if (Array.isArray(value)) {
            const arr = value;
            if (!recurse && arr.length > 0) {
                return `${toStringType}(${arr.length})`;
            }
            const lastIndex = arr.length - 1;
            const items = [];
            const end = Math.min(maxArrayChildren - 1, lastIndex);
            for (let index = 0; index <= end; index++) {
                const item = index in arr
                    ? repr(arr[index], {
                        recurse: false,
                        maxLength: recurseMaxLength,
                        sensitive,
                    })
                    : "<empty>";
                items.push(item);
            }
            if (end < lastIndex) {
                items.push(`(${lastIndex - end} more)`);
            }
            return `[${items.join(", ")}]`;
        }
        if (toStringType === "Object") {
            const object = value;
            const keys = Object.keys(object);
            // `class Foo {}` has `toStringType === "Object"` and `name === "Foo"`.
            const { name } = object.constructor;
            if (!recurse && keys.length > 0) {
                return `${name}(${keys.length})`;
            }
            const numHidden = Math.max(0, keys.length - maxObjectChildren);
            const items = keys
                .slice(0, maxObjectChildren)
                .map((key2) => `${truncate(JSON.stringify(key2), recurseMaxLength)}: ${repr(object[key2], {
                recurse: false,
                maxLength: recurseMaxLength,
                sensitive,
            })}`)
                .concat(numHidden > 0 ? `(${numHidden} more)` : []);
            const prefix = name === "Object" ? "" : `${name} `;
            return `${prefix}{${items.join(", ")}}`;
        }
        return toStringType;
    }
    catch (_error) {
        return toStringType;
    }
}
function truncate(str, maxLength) {
    const half = Math.floor(maxLength / 2);
    return str.length <= maxLength
        ? str
        : `${str.slice(0, half)}…${str.slice(-half)}`;
}
