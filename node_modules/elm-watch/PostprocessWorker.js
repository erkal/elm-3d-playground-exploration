// src/PostprocessWorker.ts
var path = require("path");
var import_tiny_decoders2 = require("tiny-decoders");
var url = require("url");
var import_worker_threads = require("worker_threads");

// src/Helpers.ts
var import_tiny_decoders = require("tiny-decoders");
function unknownErrorToString(error) {
  return typeof error?.stack === "string" ? error.stack : typeof error?.message === "string" ? error.message : (0, import_tiny_decoders.repr)(error);
}

// src/NonEmptyArray.ts
var Decode = require("tiny-decoders");
function isNonEmptyArray(array2) {
  return array2.length >= 1;
}

// src/PostprocessShared.ts
var ELM_WATCH_NODE = "elm-watch-node";

// src/PostprocessWorker.ts
var emptyStdio = {
  stdout: "",
  stderr: ""
};
function main(port) {
  port.on("messageerror", (error) => {
    throw error;
  });
  port.on("message", (message) => {
    switch (message.tag) {
      case "StartPostprocess":
        elmWatchNode(message.args).then((result) => {
          port.postMessage({
            tag: "PostprocessDone",
            result: { tag: "Resolve", value: result }
          });
        }).catch((error) => {
          port.postMessage({
            tag: "PostprocessDone",
            result: { tag: "Reject", error }
          });
        });
        break;
    }
  });
}
async function elmWatchNode({
  cwd,
  code,
  targetName,
  compilationMode,
  runMode,
  userArgs
}) {
  if (!isNonEmptyArray(userArgs)) {
    return { tag: "ElmWatchNodeMissingScript" };
  }
  const scriptPath = {
    tag: "ElmWatchNodeScriptPath",
    theElmWatchNodeScriptFileUrl: url.pathToFileURL(path.resolve(cwd.absolutePath, userArgs[0])).toString()
  };
  let imported;
  try {
    imported = await import(scriptPath.theElmWatchNodeScriptFileUrl);
  } catch (unknownError) {
    return {
      tag: "ElmWatchNodeImportError",
      scriptPath,
      error: unknownValueAsString(unknownError, importErrorToString),
      ...emptyStdio
    };
  }
  if (typeof imported.default !== "function") {
    return {
      tag: "ElmWatchNodeDefaultExportNotFunction",
      scriptPath,
      imported: unknownValueAsString(
        Object.fromEntries(Object.entries(imported)),
        (value) => (0, import_tiny_decoders2.repr)(value, { maxObjectChildren: 10 })
      ),
      typeofDefault: typeof imported.default,
      ...emptyStdio
    };
  }
  const args = {
    code,
    targetName,
    compilationMode,
    runMode,
    argv: [
      ELM_WATCH_NODE,
      url.fileURLToPath(scriptPath.theElmWatchNodeScriptFileUrl),
      ...userArgs.slice(1)
    ]
  };
  let returnValue;
  try {
    returnValue = await imported.default(args);
  } catch (unknownError) {
    return {
      tag: "ElmWatchNodeRunError",
      scriptPath,
      args,
      error: unknownValueAsString(unknownError, unknownErrorToString),
      ...emptyStdio
    };
  }
  if (typeof returnValue !== "string") {
    return {
      tag: "ElmWatchNodeBadReturnValue",
      scriptPath,
      args,
      returnValue: unknownValueAsString(returnValue, import_tiny_decoders2.repr),
      ...emptyStdio
    };
  }
  return { tag: "Success", code: returnValue };
}
function unknownValueAsString(value, toString) {
  return {
    tag: "UnknownValueAsString",
    value: toString(value)
  };
}
function importErrorToString(error) {
  const code = error?.code;
  return code === "ERR_MODULE_NOT_FOUND" || code === "MODULE_NOT_FOUND" ? error.message : unknownErrorToString(error);
}
if (import_worker_threads.parentPort === null) {
  throw new Error("PostprocessWorker.ts: worker_threads.parentPort is null!");
}
main(import_worker_threads.parentPort);
