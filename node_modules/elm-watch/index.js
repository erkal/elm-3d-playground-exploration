#!/usr/bin/env node
// src/Compile.ts
var fs7 = require("fs");

// src/ElmJson.ts
var fs2 = require("fs");
var Decode2 = require("tiny-decoders");

// src/Helpers.ts
var import_tiny_decoders = require("tiny-decoders");
function join(array4, separator) {
  return array4.join(separator);
}
function split(string7, splitter) {
  return string7.split(splitter);
}
function getSetSingleton(set) {
  return set.size === 1 ? Array.from(set)[0] : void 0;
}
var CLEAR = "\x1B[2J\x1B[3J\x1B[H";
var RESET_COLOR = "\x1B[0m";
function bold(string7) {
  return `${RESET_COLOR}\x1B[1m${string7}${RESET_COLOR}`;
}
function dim(string7) {
  return `${RESET_COLOR}\x1B[2m${string7}${RESET_COLOR}`;
}
function removeColor(string7) {
  return string7.replace(/\x1B\[\d+m/g, "");
}
function cursorHorizontalAbsolute(n) {
  return `\x1B[${n}G`;
}
function pad(number5) {
  return number5.toString().padStart(2, "0");
}
function formatTime(date) {
  return join(
    [pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds())],
    ":"
  );
}
var KiB = 1024;
var MiB = 1048576;
function printFileSize(fileSize) {
  const [divided, unit] = fileSize >= MiB ? [fileSize / MiB, "MiB"] : [fileSize / KiB, "KiB"];
  const string7 = toFixed(divided).padStart(4, " ");
  return `${string7} ${unit}`;
}
var SECOND = 1e3;
function printDurationMs(durationMs) {
  const divided = durationMs / SECOND;
  const [string7, unit] = durationMs < SECOND ? [durationMs.toString(), "ms"] : [toFixed(divided), "s"];
  return `${string7} ${unit}`.padStart(6, " ");
}
function toFixed(n) {
  const s1 = n.toFixed(2);
  if (s1.length <= 4) {
    return s1;
  }
  const s2 = n.toFixed(1);
  if (s2.length <= 4) {
    return s2;
  }
  return n.toFixed(0);
}
function capitalize(string7) {
  return string7.slice(0, 1).toUpperCase() + string7.slice(1);
}
function silentlyReadIntEnvValue(value, defaultValue) {
  return /^\d+$/.test(value ?? "") ? Number(value) : defaultValue;
}
var toError = (arg) => toError.jestWorkaround !== void 0 ? toError.jestWorkaround(arg) : arg instanceof Error ? arg : new Error(
  `Caught error not instanceof Error: ${unknownErrorToString(arg)}`
);
var toJsonError = (arg) => arg instanceof import_tiny_decoders.DecoderError ? arg : toError.jestWorkaround !== void 0 ? toError.jestWorkaround(arg) : arg instanceof SyntaxError ? arg : new SyntaxError(
  `Caught error not instanceof DecoderError or SyntaxError: ${unknownErrorToString(
    arg
  )}`
);
function unknownErrorToString(error) {
  return typeof error?.stack === "string" ? error.stack : typeof error?.message === "string" ? error.message : (0, import_tiny_decoders.repr)(error);
}

// src/NonEmptyArray.ts
var Decode = require("tiny-decoders");
function NonEmptyArray(decoder) {
  return Decode.chain(Decode.array(decoder), (array4) => {
    if (isNonEmptyArray(array4)) {
      return array4;
    }
    throw new Decode.DecoderError({
      message: "Expected a non-empty array",
      value: array4
    });
  });
}
function isNonEmptyArray(array4) {
  return array4.length >= 1;
}
function mapNonEmptyArray(array4, f) {
  return array4.map(f);
}
function flattenNonEmptyArray(array4) {
  return array4.flat();
}
function nonEmptyArrayUniqueBy(f, items) {
  const result = [items[0]];
  for (const item of items) {
    if (result.every((otherItem) => f(otherItem) !== f(item))) {
      result.push(item);
    }
  }
  return result;
}

// src/PathHelpers.ts
var fs = require("fs");
var path = require("path");
function absolutePathFromString(from, ...pathStrings) {
  return {
    tag: "AbsolutePath",
    absolutePath: path.resolve(from.absolutePath, ...pathStrings)
  };
}
function absoluteDirname({ absolutePath }) {
  return {
    tag: "AbsolutePath",
    absolutePath: path.dirname(absolutePath)
  };
}
function absoluteRealpath({ absolutePath }) {
  return {
    tag: "AbsolutePath",
    absolutePath: fs.realpathSync(absolutePath)
  };
}
function findClosest(name, absoluteDir) {
  const dir = absoluteDir.absolutePath;
  const entry = path.join(dir, name);
  return fs.existsSync(entry) ? { tag: "AbsolutePath", absolutePath: entry } : dir === path.parse(dir).root ? void 0 : findClosest(name, absoluteDirname(absoluteDir));
}
function longestCommonAncestorPath(paths) {
  const pathArrays = mapNonEmptyArray(
    paths,
    ({ absolutePath }) => absolutePath.split(path.sep)
  );
  const length = Math.min(...pathArrays.map((array4) => array4.length));
  const commonSegments = [];
  for (let index = 0; index < length; index++) {
    const segmentsAtIndex = new Set(pathArrays.map((array4) => array4[index]));
    const uniqueSegment = getSetSingleton(segmentsAtIndex);
    if (uniqueSegment === void 0) {
      break;
    }
    commonSegments.push(uniqueSegment);
  }
  return isNonEmptyArray(commonSegments) ? { tag: "AbsolutePath", absolutePath: join(commonSegments, path.sep) } : void 0;
}

// src/ElmJson.ts
var ElmJson = Decode2.fieldsUnion("type", {
  application: Decode2.fieldsAuto({
    tag: () => "Application",
    "source-directories": NonEmptyArray(Decode2.string)
  }),
  package: () => ({
    tag: "Package"
  })
});
function readAndParse(elmJsonPath) {
  let json2 = void 0;
  try {
    json2 = JSON.parse(
      fs2.readFileSync(elmJsonPath.theElmJsonPath.absolutePath, "utf-8")
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ElmJsonReadAsJsonError",
      elmJsonPath,
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmJson: ElmJson(json2)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmJsonDecodeError",
      elmJsonPath,
      error
    };
  }
}
function getSourceDirectories(elmJsonPath, elmJson2) {
  const base = absoluteDirname(elmJsonPath.theElmJsonPath);
  switch (elmJson2.tag) {
    case "Application":
      return mapNonEmptyArray(elmJson2["source-directories"], (dir) => ({
        tag: "SourceDirectory",
        theSourceDirectory: absolutePathFromString(base, dir)
      }));
    case "Package":
      return [
        {
          tag: "SourceDirectory",
          theSourceDirectory: absolutePathFromString(base, "src")
        }
      ];
  }
}

// src/Env.ts
var NO_COLOR = "NO_COLOR";
var ELM_WATCH_OPEN_EDITOR = "ELM_WATCH_OPEN_EDITOR";
var ELM_WATCH_EXIT_ON_STDIN_END = "ELM_WATCH_EXIT_ON_STDIN_END";
var __ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS = "__ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS";
var __ELM_WATCH_DEBUG = "__ELM_WATCH_DEBUG";
var __ELM_WATCH_NOT_TTY = "__ELM_WATCH_NOT_TTY";
var WT_SESSION = "WT_SESSION";
var __ELM_WATCH_MOCKED_TIMINGS = "__ELM_WATCH_MOCKED_TIMINGS";
var __ELM_WATCH_EXIT_ON_ERROR = "__ELM_WATCH_EXIT_ON_ERROR";
var __ELM_WATCH_LOADING_MESSAGE_DELAY = "__ELM_WATCH_LOADING_MESSAGE_DELAY";
var __ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS = "__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS";
var __ELM_WATCH_EXIT_ON_WORKER_LIMIT = "__ELM_WATCH_EXIT_ON_WORKER_LIMIT";
var __ELM_WATCH_MAX_PARALLEL = "__ELM_WATCH_MAX_PARALLEL";
var __ELM_WATCH_TMP_DIR = "__ELM_WATCH_TMP_DIR";
var __ELM_WATCH_ELM_TIMEOUT_MS = "__ELM_WATCH_ELM_TIMEOUT_MS";
var __ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS = "__ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS";
var __ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS = "__ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS";

// src/Errors.ts
var crypto = require("crypto");
var fs4 = require("fs");
var path3 = require("path");
var import_tiny_decoders2 = require("tiny-decoders");
var url = require("url");

// src/ElmWatchJson.ts
var fs3 = require("fs");
var path2 = require("path");
var Decode4 = require("tiny-decoders");

// src/IsWindows.ts
var os = require("os");
var IS_WINDOWS = os.platform() === "win32";

// src/Port.ts
var Decode3 = require("tiny-decoders");
var Port = Decode3.chain(Decode3.number, (number5) => {
  const min = 1;
  const max = 65535;
  if (Number.isInteger(number5) && min <= number5 && number5 <= max) {
    return {
      tag: "Port",
      thePort: number5
    };
  }
  throw new Decode3.DecoderError({
    message: `Expected an integer where ${min} <= port <= ${max}`,
    value: number5
  });
});

// src/ElmWatchJson.ts
var INPUT_NAME = /(^|[/\\])\p{Lu}[_\d\p{L}]*\.elm$/u;
function isValidInputName(name) {
  return INPUT_NAME.test(name);
}
function isValidOutputName(name) {
  return !name.startsWith("-") && name.endsWith(".js") && name !== ".js";
}
var TARGET_NAME = /^[^\s-](?:.*\S)?$/;
function isValidTargetName(name) {
  return TARGET_NAME.test(name);
}
var Target = Decode4.fieldsAuto(
  {
    inputs: NonEmptyArray(
      Decode4.chain(Decode4.string, (string7) => {
        if (isValidInputName(string7)) {
          return string7;
        }
        throw new Decode4.DecoderError({
          message: "Inputs must have a valid module name and end with .elm",
          value: string7
        });
      })
    ),
    output: Decode4.chain(Decode4.string, (output) => {
      if (isValidOutputName(output)) {
        return output;
      }
      throw new Decode4.DecoderError({
        message: "Outputs must end with .js",
        value: Decode4.DecoderError.MISSING_VALUE
      });
    })
  },
  { exact: "throw" }
);
function targetRecordHelper(record3) {
  const entries = Object.entries(record3);
  if (!isNonEmptyArray(entries)) {
    throw new Decode4.DecoderError({
      message: "Expected a non-empty object",
      value: record3
    });
  }
  return Object.fromEntries(
    entries.map(([key, value]) => {
      if (isValidTargetName(key)) {
        return [key, value];
      }
      throw new Decode4.DecoderError({
        message: "Target names must start with a non-whitespace character except `-`,\ncannot contain newlines and must end with a non-whitespace character",
        value: Decode4.DecoderError.MISSING_VALUE,
        key
      });
    })
  );
}
var Config = Decode4.fieldsAuto(
  {
    targets: Decode4.chain(Decode4.record(Target), targetRecordHelper),
    postprocess: Decode4.optional(NonEmptyArray(Decode4.string)),
    port: Decode4.optional(Port)
  },
  { exact: "throw" }
);
function findReadAndParse(cwd) {
  const elmWatchJsonPathRaw = findClosest("elm-watch.json", cwd.path);
  if (elmWatchJsonPathRaw === void 0) {
    return {
      tag: "ElmWatchJsonNotFound"
    };
  }
  const elmWatchJsonPath = {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPathRaw
  };
  let json2 = void 0;
  try {
    json2 = JSON.parse(
      fs3.readFileSync(elmWatchJsonPathRaw.absolutePath, "utf-8")
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ReadAsJsonError",
      elmWatchJsonPath,
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmWatchJsonPath,
      config: Config(json2)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "DecodeError",
      elmWatchJsonPath,
      error
    };
  }
}
function example(cwd, elmWatchJsonPath, elmMakeParsed) {
  const { elmFiles, output = "build/main.js" } = elmMakeParsed;
  const json2 = {
    targets: {
      "My target name": {
        inputs: isNonEmptyArray(elmFiles) ? mapNonEmptyArray(
          elmFiles,
          (file) => toUnixPath(
            path2.relative(
              path2.dirname(
                elmWatchJsonPath.theElmWatchJsonPath.absolutePath
              ),
              path2.resolve(cwd.path.absolutePath, file)
            )
          )
        ) : ["src/Main.elm"],
        output
      }
    }
  };
  return JSON.stringify(json2, null, 4);
}
function toUnixPath(filePath) {
  return IS_WINDOWS ? filePath.split(path2.sep).join(path2.posix.sep) : filePath;
}
function parseArgsLikeElmMake(args) {
  return args.reduce(
    (passedParsed, { theArg: arg }) => {
      const parsed = { ...passedParsed, justSawOutputFlag: false };
      switch (arg) {
        case "--debug":
        case "--optimize":
          return parsed;
        case "--output":
          return { ...parsed, justSawOutputFlag: true };
        default: {
          if (passedParsed.justSawOutputFlag) {
            return isValidOutputName(arg) ? { ...parsed, output: arg } : parsed;
          }
          const outputPrefix = "--output=";
          if (arg.startsWith(outputPrefix)) {
            const file = arg.slice(outputPrefix.length);
            return isValidOutputName(file) ? { ...parsed, output: file } : parsed;
          }
          return isValidInputName(arg) ? { ...parsed, elmFiles: parsed.elmFiles.concat(arg) } : parsed;
        }
      }
    },
    {
      elmFiles: [],
      output: void 0,
      justSawOutputFlag: false
    }
  );
}

// src/Logger.ts
var readline = require("readline");
var util = require("util");
var DEFAULT_COLUMNS = 80;
function makeLogger({
  env,
  getNow,
  stdin,
  stdout,
  stderr,
  logDebug
}) {
  const noColor = NO_COLOR in env;
  const handleColor = (string7) => noColor ? removeColor(string7) : string7;
  let queryTerminalStatus = { tag: "NotQueried" };
  const defaultOnExit = () => {
  };
  let onExit = defaultOnExit;
  const exitOnCtrlC = (data) => {
    if (data.toString("utf8") === "") {
      onExit();
    }
  };
  const exitOnStdinEnd = () => {
    onExit();
  };
  const queryTerminalTimeoutMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS],
    100
  );
  const queryTerminalMaxAgeMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS],
    1e3
  );
  const config = {
    debug: __ELM_WATCH_DEBUG in env,
    noColor,
    fancy: (!IS_WINDOWS || WT_SESSION in env) && !noColor,
    isTTY: __ELM_WATCH_NOT_TTY in env ? false : stdout.isTTY,
    mockedTimings: __ELM_WATCH_MOCKED_TIMINGS in env,
    get columns() {
      return stdout.columns ?? DEFAULT_COLUMNS;
    }
  };
  if (ELM_WATCH_EXIT_ON_STDIN_END in env) {
    stdin.on("end", exitOnStdinEnd);
    stdin.resume();
  }
  return {
    write(message) {
      stdout.write(`${handleColor(message)}
`);
    },
    writeToStderrMakesALotOfSenseHere(message) {
      stderr.write(`${handleColor(message)}
`);
    },
    errorTemplate(template2) {
      stdout.write(
        `${toTerminalString(template2, config.columns, noColor)}
`
      );
    },
    debug(...args) {
      if (config.debug) {
        logDebug(
          join(
            args.map(
              (arg, index) => index === 0 && typeof arg === "string" && !noColor ? bold(arg) : util.inspect(arg, {
                depth: Infinity,
                colors: !noColor,
                maxStringLength: 1e3
              })
            ),
            "\n"
          )
        );
      }
    },
    clearScreen() {
      if (config.isTTY) {
        stdout.write(CLEAR);
      }
    },
    clearScreenDown() {
      if (config.isTTY) {
        readline.clearScreenDown(stdout);
      }
    },
    clearLine(dir) {
      if (config.isTTY) {
        readline.clearLine(stdout, dir);
      }
    },
    moveCursor(dx, dy) {
      if (config.isTTY) {
        readline.moveCursor(stdout, dx, dy);
      }
    },
    setRawMode(passedOnExit) {
      onExit = passedOnExit;
      if (stdin.isTTY && stdout.isTTY && !stdin.isRaw) {
        stdin.setRawMode(true);
        stdin.on("data", exitOnCtrlC);
        stdin.resume();
      }
    },
    reset() {
      onExit = defaultOnExit;
      queryTerminalStatus = { tag: "NotQueried" };
      stdin.pause();
      stdin.off("data", exitOnCtrlC);
      stdin.off("end", exitOnStdinEnd);
      if (stdin.isRaw) {
        stdin.setRawMode(false);
      }
    },
    async queryTerminal(escapes, isDone) {
      if (!stdin.isRaw) {
        return void 0;
      }
      const run4 = async () => {
        const callbacks = [];
        queryTerminalStatus = { tag: "Querying", callbacks };
        const result = await queryTerminalHelper(
          queryTerminalTimeoutMs,
          stdin,
          stdout,
          escapes,
          isDone
        );
        queryTerminalStatus = {
          tag: "Queried",
          stdin: result,
          date: getNow()
        };
        for (const callback of callbacks) {
          callback(result);
        }
        return result;
      };
      switch (queryTerminalStatus.tag) {
        case "NotQueried":
          return run4();
        case "Querying": {
          const { callbacks } = queryTerminalStatus;
          return new Promise((resolve3) => {
            callbacks.push(resolve3);
          });
        }
        case "Queried":
          return getNow().getTime() - queryTerminalStatus.date.getTime() <= queryTerminalMaxAgeMs ? queryTerminalStatus.stdin : run4();
      }
    },
    config
  };
}
async function queryTerminalHelper(queryTerminalTimeoutMs, stdin, stdout, escapes, isDone) {
  return new Promise((resolve3) => {
    let stdinString = "";
    const onStdin = (data) => {
      stdinString += data.toString("utf8");
      if (isDone(stdinString)) {
        clearTimeout(timeoutId);
        stdin.off("data", onStdin);
        resolve3(stdinString);
      }
    };
    stdin.on("data", onStdin);
    stdout.write(escapes);
    const timeoutId = setTimeout(() => {
      stdin.off("data", onStdin);
      resolve3(void 0);
    }, queryTerminalTimeoutMs);
  });
}

// src/PostprocessShared.ts
var ELM_WATCH_NODE = "elm-watch-node";

// src/Theme.ts
var THEME_ESCAPES_STRING = Array.from(
  { length: 16 },
  (_, i) => `\x1B]4;${i};?\x1B\\`
).concat("\x1B]10;?\x1B\\", "\x1B]11;?\x1B\\").join("");
var THEME_ESCAPES_DONE_CHECK = "]11;";
var THEME_ESCAPES_REGEX = /\x1B](4;)?(\d+);rgb:([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})/gi;
var INDEX_TO_COLOR = {
  0: "black",
  1: "red",
  2: "green",
  3: "yellow",
  4: "blue",
  5: "magenta",
  6: "cyan",
  7: "white",
  8: "BLACK",
  9: "RED",
  10: "GREEN",
  11: "YELLOW",
  12: "BLUE",
  13: "MAGENTA",
  14: "CYAN",
  15: "WHITE"
};
var COLOR_TO_TERMINAL_ESCAPE = {
  red: "\x1B[31m",
  RED: "\x1B[91m",
  magenta: "\x1B[35m",
  MAGENTA: "\x1B[95m",
  yellow: "\x1B[33m",
  YELLOW: "\x1B[93m",
  green: "\x1B[32m",
  GREEN: "\x1B[92m",
  cyan: "\x1B[36m",
  CYAN: "\x1B[96m",
  blue: "\x1B[34m",
  BLUE: "\x1B[94m",
  black: "\x1B[30m",
  BLACK: "\x1B[90m",
  white: "\x1B[37m",
  WHITE: "\x1B[97m"
};
var DEFAULT_THEME = {
  foreground: "rgb(204, 204, 204)",
  background: "rgb(32, 30, 30)",
  palette: {
    red: "rgb(205, 49, 49)",
    RED: "rgb(241, 76, 76)",
    magenta: "rgb(188, 63, 188)",
    MAGENTA: "rgb(214, 112, 214)",
    yellow: "rgb(229, 229, 16)",
    YELLOW: "rgb(245, 245, 67)",
    green: "rgb(13, 188, 121)",
    GREEN: "rgb(35, 209, 139)",
    cyan: "rgb(17, 168, 205)",
    CYAN: "rgb(41, 184, 219)",
    blue: "rgb(36, 114, 200)",
    BLUE: "rgb(59, 142, 234)",
    black: "rgb(0, 0, 0)",
    BLACK: "rgb(102, 102, 102)",
    white: "rgb(229, 229, 229)",
    WHITE: "rgb(229, 229, 229)"
  }
};
async function getThemeFromTerminal(logger) {
  if (IS_WINDOWS) {
    return DEFAULT_THEME;
  }
  const stdin = await logger.queryTerminal(
    THEME_ESCAPES_STRING,
    (stdinSoFar) => stdinSoFar.includes(THEME_ESCAPES_DONE_CHECK)
  );
  return stdin === void 0 ? DEFAULT_THEME : parseTheme(stdin);
}
function parseTheme(stdin) {
  const theme = { ...DEFAULT_THEME, palette: { ...DEFAULT_THEME.palette } };
  for (const match of stdin.matchAll(THEME_ESCAPES_REGEX)) {
    const [, isPaletteString, indexString, r = "0", g = "0", b = "0"] = match;
    const isPalette = isPaletteString !== void 0;
    const index = Number(indexString);
    const color = `#${convert(r)}${convert(g)}${convert(b)}`;
    if (isPalette) {
      const colorName = INDEX_TO_COLOR[index];
      if (colorName !== void 0) {
        theme.palette[colorName] = color;
      }
    } else if (index === 10) {
      theme.foreground = color;
    } else if (index === 11) {
      theme.background = color;
    }
  }
  return theme;
}
function convert(hexDigits) {
  return Math.floor(parseInt(hexDigits, 16) / 65535 * 255).toString(16).padStart(2, "0");
}

// src/Errors.ts
function bold2(string7) {
  return { tag: "Bold", text: string7 };
}
function dim2(string7) {
  return { tag: "Dim", text: string7 };
}
function text(string7) {
  return { tag: "Text", text: string7.trim() };
}
function number2(num) {
  return { tag: "Text", text: num.toString() };
}
function join3(array4, separator) {
  return text(join(array4, separator));
}
function json(data, indent) {
  return {
    tag: "Text",
    text: indent === void 0 ? JSON.stringify(data) : JSON.stringify(data, null, indent)
  };
}
function joinTemplate(array4, separator) {
  return template(
    ["", ...Array.from({ length: array4.length - 1 }, () => separator), ""],
    ...array4
  );
}
var elmJson = bold2("elm.json");
var elmWatchJson = bold2("elm-watch.json");
var elmWatchStuffJson = bold2("elm-stuff/elm-watch/stuff.json");
var fancyError = (title, location) => (strings, ...values) => (width, renderPiece) => ({
  title,
  location: fancyToPlainErrorLocation(location),
  content: template(strings, ...values)(width, renderPiece)
});
var template = (strings, ...values) => (width, renderPiece) => join(
  strings.flatMap((string7, index) => {
    const value = values[index] ?? text("");
    return [
      string7,
      typeof value === "function" ? value(width, renderPiece) : renderPiece(value)
    ];
  }),
  ""
).trim();
function toTerminalString(errorTemplate, width, noColor) {
  const renderPiece = noColor ? (piece) => piece.text : renderPieceForTerminal;
  const { title, location, content } = errorTemplate(width, renderPiece);
  const prefix = `-- ${title} `;
  const line = "-".repeat(Math.max(0, width - prefix.length));
  const titleWithSeparator = renderPiece(bold2(`${prefix}${line}`));
  return join(
    [
      titleWithSeparator,
      ...location === void 0 ? [] : [renderPiece(renderErrorLocation(location))],
      "",
      content
    ],
    "\n"
  );
}
function toPlainString(errorTemplate) {
  return toTerminalString(errorTemplate, DEFAULT_COLUMNS, true);
}
function toHtml(errorTemplate, theme, noColor) {
  const renderPiece = (piece) => noColor ? piece.text : renderPieceToHtml(piece, theme);
  const { title, location, content } = errorTemplate(
    DEFAULT_COLUMNS,
    renderPiece
  );
  return { title, location, htmlContent: content };
}
function renderPieceForTerminal(piece) {
  switch (piece.tag) {
    case "Bold":
      return bold(piece.text);
    case "Dim":
      return dim(piece.text);
    case "ElmStyle":
      return (piece.bold ? "\x1B[1m" : "") + (piece.underline ? "\x1B[4m" : "") + (piece.color === void 0 ? "" : COLOR_TO_TERMINAL_ESCAPE[piece.color]) + piece.text + RESET_COLOR;
    case "Text":
      return piece.text;
  }
}
function renderPieceToHtml(piece, theme) {
  switch (piece.tag) {
    case "Bold":
      return `<b>${escapeHtml(piece.text)}</b>`;
    case "Dim":
      return `<span style="opacity: 0.6">${escapeHtml(piece.text)}</span>`;
    case "ElmStyle":
      return (piece.bold ? "<b>" : "") + (piece.underline ? "<u>" : "") + (piece.color === void 0 ? "" : `<span style="color: ${theme.palette[piece.color]}">`) + escapeHtml(piece.text) + (piece.color === void 0 ? "" : "</span>") + (piece.underline ? "</u>" : "") + (piece.bold ? "</b>" : "");
    case "Text":
      return escapeHtml(piece.text);
  }
}
function escapeHtml(string7) {
  return string7.replace(/[&<>"']/g, (match) => {
    switch (match) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      default:
        return match;
    }
  });
}
function fancyToPlainErrorLocation(location) {
  switch (location.tag) {
    case "ElmJsonPath":
      return { tag: "FileOnly", file: location.theElmJsonPath };
    case "ElmWatchJsonPath":
      return { tag: "FileOnly", file: location.theElmWatchJsonPath };
    case "ElmWatchStuffJsonPath":
      return { tag: "FileOnly", file: location.theElmWatchStuffJsonPath };
    case "OutputPath":
      return { tag: "Target", targetName: location.targetName };
    case "ElmWatchNodeScriptPath":
      return {
        tag: "FileOnly",
        file: {
          tag: "AbsolutePath",
          absolutePath: url.fileURLToPath(
            location.theElmWatchNodeScriptFileUrl
          )
        }
      };
    case "FileWithLineAndColumn":
      return location;
    case "NoLocation":
      return void 0;
  }
}
function renderErrorLocation(location) {
  switch (location.tag) {
    case "FileOnly":
      return text(location.file.absolutePath);
    case "FileWithLineAndColumn":
      return text(
        `${location.file.absolutePath}:${location.line}:${location.column}`
      );
    case "Target":
      return dim2(`Target: ${location.targetName}`);
  }
}
function readElmWatchJsonAsJson(elmWatchJsonPath, error) {
  return fancyError("TROUBLE READING elm-watch.json", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("I had trouble reading it as JSON:")}

${text(error.message)}
`;
}
function decodeElmWatchJson(elmWatchJsonPath, error) {
  return fancyError("INVALID elm-watch.json FORMAT", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}
`;
}
function elmWatchJsonNotFound(cwd, args) {
  const example2 = example(
    cwd,
    {
      tag: "ElmWatchJsonPath",
      theElmWatchJsonPath: absolutePathFromString(cwd.path, "elm-watch.json")
    },
    parseArgsLikeElmMake(args)
  );
  return fancyError("elm-watch.json NOT FOUND", { tag: "NoLocation" })`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("But I couldn't find one!")}

You need to create one with JSON like this:

${text(example2)}
`;
}
function debugOptimizeForHot() {
  const make2 = bold2("elm-watch make");
  const hot = bold2("elm-watch hot");
  return fancyError("REDUNDANT FLAGS", { tag: "NoLocation" })`
${bold2("--debug")} and ${bold2("--optimize")} only make sense for ${make2}.
When using ${hot}, you can switch mode in the browser.
`;
}
function debugOptimizeClash() {
  return fancyError("CLASHING FLAGS", { tag: "NoLocation" })`
${bold2("--debug")} and ${bold2("--optimize")} cannot be used at the same time.
`;
}
function unknownFlags(cwd, elmWatchJsonPath, runMode, args, theUnknownFlags) {
  const elmMakeParsed = parseArgsLikeElmMake(args);
  const extra = elmMakeParsed.output !== void 0 ? template`
It looks like your arguments might fit in an ${bold2("elm make")} command.
If so, you could try moving them to the ${elmWatchJson} I found here:

${text(elmWatchJsonPath.theElmWatchJsonPath.absolutePath)}

For example, you could add some JSON like this:

${text(example(cwd, elmWatchJsonPath, elmMakeParsed))}
  ` : text("");
  return fancyError("UNEXPECTED FLAGS", { tag: "NoLocation" })`
${printRunModeArgsHelp(runMode)}

But you provided these flag-looking args:

${join3(
    theUnknownFlags.map((arg) => arg.theArg),
    "\n"
  )}

Try removing those extra flags!

${extra}
`;
}
function printRunModeArgsHelp(runMode) {
  switch (runMode) {
    case "make":
      return template`The ${bold2(
        runMode
      )} command only accepts the flags ${bold2("--debug")} and ${bold2(
        "--optimize"
      )}.`;
    case "hot":
      return template`The ${bold2(
        runMode
      )} command only accepts no flags at all.`;
  }
}
function unknownTargetsSubstrings(elmWatchJsonPath, knownTargets, theUnknownTargetsSubstrings) {
  return fancyError("UNKNOWN TARGETS SUBSTRINGS", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

It contains these targets:

${join3(knownTargets, "\n")}

${bold2("But none of those match these substrings you gave me:")}

${join3(theUnknownTargetsSubstrings, "\n")}

Is something misspelled?
Or do you need to add some more targets?
`;
}
function noCommonRoot(paths) {
  return fancyError("NO COMMON ROOT", { tag: "NoLocation" })`
I could not find a common ancestor for these paths:

${join3(
    mapNonEmptyArray(paths, (thePath) => thePath.absolutePath),
    "\n"
  )}

${bold2("Compiling files on different drives is not supported.")}
`;
}
function elmJsonNotFound(outputPath, inputs, foundElmJsonPaths) {
  const extra = isNonEmptyArray(foundElmJsonPaths) ? template`
Note that I did find an ${elmJson} for some inputs:

${join3(
    mapNonEmptyArray(
      foundElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath.theElmJsonPath.absolutePath}`
    ),
    "\n\n"
  )}

Make sure that one single ${elmJson} covers all the inputs together!
      ` : text("");
  return fancyError("elm.json NOT FOUND", outputPath)`
I could not find an ${elmJson} for these inputs:

${join3(
    mapNonEmptyArray(inputs, (inputPath) => inputPath.originalString),
    "\n"
  )}

Has it gone missing? Maybe run ${bold2("elm init")} to create one?

${extra}
`;
}
function nonUniqueElmJsonPaths(outputPath, theNonUniqueElmJsonPaths) {
  return fancyError("NO UNIQUE elm.json", outputPath)`
I went looking for an ${elmJson} for your inputs, but I found more than one!

${join3(
    mapNonEmptyArray(
      theNonUniqueElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath.theElmJsonPath.absolutePath}`
    ),
    "\n\n"
  )}

It doesn't make sense to compile Elm files from different projects into one output.

Either split this target, or move the inputs to the same project with the same
${elmJson}.
`;
}
function inputsNotFound(outputPath, inputs) {
  return fancyError("INPUTS NOT FOUND", outputPath)`
You asked me to compile these inputs:

${joinTemplate(
    mapNonEmptyArray(
      inputs,
      (inputPath) => template`${text(inputPath.originalString)} ${dim2(
        `(${inputPath.theUncheckedInputPath.absolutePath})`
      )}`
    ),
    "\n"
  )}

${bold2("But they don't exist!")}

Is something misspelled? Or do you need to create them?
`;
}
function inputsFailedToResolve(outputPath, inputs) {
  return fancyError("INPUTS FAILED TO RESOLVE", outputPath)`
I start by checking if the inputs you give me exist,
but doing so resulted in errors!

${join3(
    mapNonEmptyArray(
      inputs,
      ({ inputPath, error }) => `${inputPath.originalString}:
${error.message}`
    ),
    "\n\n"
  )}

${bold2("That's all I know, unfortunately!")}
`;
}
function duplicateInputs(outputPath, duplicates) {
  const isSymlink = (inputPath) => inputPath.theInputPath.absolutePath !== inputPath.realpath.absolutePath;
  const hasSymlink = duplicates.some(({ inputs }) => inputs.some(isSymlink));
  const symlinkText = hasSymlink ? "Note that at least one of the inputs seems to be a symlink. They can be tricky!" : "";
  return fancyError("DUPLICATE INPUTS", outputPath)`
Some of your inputs seem to be duplicates!

${joinTemplate(
    mapNonEmptyArray(
      duplicates,
      ({ inputs, resolved }) => joinTemplate(
        [
          ...mapNonEmptyArray(
            inputs,
            (inputPath) => isSymlink(inputPath) ? template`${text(inputPath.originalString)} ${dim2("(symlink)")}` : text(inputPath.originalString)
          ),
          text(`-> ${resolved.absolutePath}`)
        ],
        "\n"
      )
    ),
    "\n\n"
  )}

Make sure every input is listed just once!

${text(symlinkText)}
`;
}
function duplicateOutputs(elmWatchJsonPath, duplicates) {
  return fancyError("DUPLICATE OUTPUTS", elmWatchJsonPath)`
Some of your outputs seem to be duplicates!

${joinTemplate(
    mapNonEmptyArray(
      duplicates,
      ({ originalOutputPathStrings, absolutePath }) => join3(
        [...originalOutputPathStrings, `-> ${absolutePath.absolutePath}`],
        "\n"
      )
    ),
    "\n\n"
  )}

Make sure every output is listed just once!
`;
}
function elmNotFoundError(location, command) {
  return fancyError("ELM NOT FOUND", location)`
I tried to execute ${bold2(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is Elm installed?

Note: If you have installed Elm locally (for example using npm or elm-tooling),
execute elm-watch using npx to make elm-watch automatically pick up that local
installation: ${bold2("npx elm-watch")}
`;
}
function commandNotFoundError(outputPath, command) {
  return fancyError("COMMAND NOT FOUND", outputPath)`
I tried to execute ${bold2(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is ${bold2(command.command)} installed?
`;
}
function otherSpawnError(location, error, command) {
  return fancyError("TROUBLE SPAWNING COMMAND", location)`
I tried to execute ${bold2(command.command)}, but I ran into an error!

${text(error.message)}

This happened when trying to run the following commands:

${printCommand(command)}
`;
}
function unexpectedElmMakeOutput(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", outputPath)`
I ran the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with JSON on stderr (compile errors).

${bold2("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function unexpectedElmInstallOutput(elmJsonPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", elmJsonPath)`
I tried to make sure all packages are installed by running the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with an error I can recognize (using regex) on stderr.

${bold2("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function postprocessStdinWriteError(location, error, command) {
  return fancyError("POSTPROCESS STDIN TROUBLE", location)`
I tried to run your postprocess command:

${printCommand(command)}

Trying to write to its ${bold2("stdin")}, I got an error!
${bold2("Did you forget to read stdin, maybe?")}

Note: If you don't need stdin in some case, you can pipe it to stdout!

This is the error message I got:

${text(error.message)}
`;
}
function postprocessNonZeroExit(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("POSTPROCESS ERROR", outputPath)`
I ran your postprocess command:

${printCommand(command)}

${bold2("It exited with an error:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function elmWatchNodeMissingScript(elmWatchJsonPath) {
  return fancyError("MISSING POSTPROCESS SCRIPT", elmWatchJsonPath)`
You have specified this in ${elmWatchJson}:

"postprocess": [${json(ELM_WATCH_NODE)}]

You need to specify a JavaScript file to run as well, like so:

"postprocess": [${json(ELM_WATCH_NODE)}, "postprocess.js"]
`;
}
function elmWatchNodeImportError(scriptPath, error, stdout, stderr) {
  return fancyError("POSTPROCESS IMPORT ERROR", scriptPath)`
I tried to import your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeDefaultExportNotFunction(scriptPath, imported, typeofDefault, stdout, stderr) {
  const moduleExports = text("module.exports");
  return fancyError("MISSING POSTPROCESS DEFAULT EXPORT", scriptPath)`
I imported your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

I expected ${bold2("imported.default")} to be a function, but it isn't!

typeof imported.default === ${json(typeofDefault)}

${bold2("imported")} is:

${printUnknownValueAsString(imported)}

Here is a sample function to get you started:

// CJS
${moduleExports} = async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

// MJS
export default async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeRunError(scriptPath, args, error, stdout, stderr) {
  return fancyError("POSTPROCESS RUN ERROR", scriptPath)`
I tried to run your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeBadReturnValue(scriptPath, args, returnValue, stdout, stderr) {
  return fancyError("INVALID POSTPROCESS RESULT", scriptPath)`
I ran your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

I expected ${bold2("result")} to be a string, but it is:

${printUnknownValueAsString(returnValue)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function printElmMakeCrashBeforeError(beforeError) {
  switch (beforeError.tag) {
    case "Json":
      return template`I got back ${number2(
        beforeError.length
      )} characters of JSON, but then Elm crashed with this error:`;
    case "Text":
      return beforeError.text === "" ? template`Elm crashed with this error:` : template`Elm printed this text:

${text(beforeError.text)}

Then it crashed with this error:`;
  }
}
function elmMakeCrashError(outputPath, beforeError, error, command) {
  return fancyError("ELM CRASHED", outputPath)`
I ran the following commands:

${printCommand(command)}

${printElmMakeCrashBeforeError(beforeError)}

${text(error)}
`;
}
function elmMakeJsonParseError(outputPath, error, errorFilePath, command) {
  return fancyError("TROUBLE WITH JSON REPORT", outputPath)`
I ran the following commands:

${printCommand(command)}

I seem to have gotten some JSON back as expected,
but I ran into an error when decoding it:

${printJsonError(error)}

${printErrorFilePath(errorFilePath)}
`;
}
function elmMakeGeneralError(outputPath, elmJsonPath, error, extraError) {
  return fancyError(
    error.title,
    generalErrorPath(outputPath, elmJsonPath, error.path)
  )`
${text(extraError ?? "")}

${joinTemplate(error.message.map(renderMessageChunk), "")}
`;
}
function generalErrorPath(outputPath, elmJsonPath, errorPath) {
  switch (errorPath.tag) {
    case "NoPath":
      return outputPath;
    case "elm.json":
      return elmJsonPath;
  }
}
function elmMakeProblem(filePath, problem, extraError) {
  return fancyError(problem.title, {
    tag: "FileWithLineAndColumn",
    file: filePath,
    line: problem.region.start.line,
    column: problem.region.start.column
  })`
${text(extraError ?? "")}

${joinTemplate(problem.message.map(renderMessageChunk), "")}
`;
}
function renderMessageChunk(chunk) {
  switch (chunk.tag) {
    case "UnstyledText":
      return { tag: "Text", text: chunk.string };
    case "StyledText":
      return {
        tag: "ElmStyle",
        text: chunk.string,
        bold: chunk.bold,
        underline: chunk.underline,
        color: chunk.color
      };
  }
}
function stuckInProgressState(outputPath, state) {
  return fancyError("STUCK IN PROGRESS", outputPath)`
I thought that all outputs had finished compiling, but my inner state says
this target is still in the ${bold2(state)} phase.

${bold2("This is not supposed to ever happen.")}
`;
}
function creatingDummyFailed(elmJsonPath, error) {
  return fancyError("FILE SYSTEM TROUBLE", elmJsonPath)`
I tried to make sure that all packages are installed. To do that, I need to
create a temporary dummy .elm file but that failed:

${text(error.message)}
`;
}
function elmInstallError(elmJsonPath, title, message) {
  return fancyError(title, elmJsonPath)`
${text(message)}
`;
}
function readElmJsonAsJson(elmJsonPath, error) {
  return fancyError("TROUBLE READING elm.json", elmJsonPath)`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold2("I had trouble reading it as JSON:")}

${text(error.message)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function decodeElmJson(elmJsonPath, error) {
  return fancyError("INVALID elm.json FORMAT", elmJsonPath)`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function readElmWatchStuffJsonAsJson(elmWatchStuffJsonPath, error) {
  return fancyError(
    "TROUBLE READING elm-stuff/elm-watch/stuff.json",
    elmWatchStuffJsonPath
  )`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble reading it as JSON:")}

${text(error.message)}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function decodeElmWatchStuffJson(elmWatchStuffJsonPath, error) {
  return fancyError(
    "INVALID elm-stuff/elm-watch/stuff.json FORMAT",
    elmWatchStuffJsonPath
  )`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function elmWatchStuffJsonWriteError(elmWatchStuffJsonPath, error) {
  return fancyError(
    "TROUBLE WRITING elm-stuff/elm-watch/stuff.json",
    elmWatchStuffJsonPath
  )`
I write stuff to ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble writing that file:")}

${text(error.message)}

The file contains nothing essential, but something weird is going on.
`;
}
function importWalkerFileSystemError(outputPath, error) {
  return fancyError("TROUBLE READING ELM FILES", outputPath)`
When figuring out all Elm files that your inputs depend on I read a lot of Elm files.
Doing so I encountered this error:

${text(error.message)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function needsToWriteProxyFileReadError(outputPath, error, triedPath) {
  return fancyError("TROUBLE CHECKING OUTPUT", outputPath)`
I managed to typecheck your code. Then I tried to read part of the previous output,
to see if I need to write a dummy output file there:

${text(triedPath.absolutePath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function readOutputError(outputPath, error, triedPath) {
  return fancyError("TROUBLE READING OUTPUT", outputPath)`
I managed to compile your code. Then I tried to read the output:

${text(triedPath.absolutePath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function writeOutputError(outputPath, error, reasonForWriting) {
  return fancyError("TROUBLE WRITING OUTPUT", outputPath)`
I managed to compile your code and read the generated file:

${text(outputPath.temporaryOutputPath.absolutePath)}

${printWriteOutputErrorReasonForWriting(reasonForWriting)}

${text(outputPath.theOutputPath.absolutePath)}

But I encountered this error:

${text(error.message)}
`;
}
function printWriteOutputErrorReasonForWriting(reasonForWriting) {
  switch (reasonForWriting) {
    case "InjectWebSocketClient":
      return text(
        "I injected code for hot reloading, and then tried to write that to the output path:"
      );
    case "Postprocess":
      return text(
        "After running your postprocess command, I tried to write the result of that to the output path:"
      );
  }
}
function writeProxyOutputError(outputPath, error) {
  return fancyError("TROUBLE WRITING DUMMY OUTPUT", outputPath)`
There are no WebSocket connections for this target, so I only typecheck the
code. That went well. Then I tried to write a dummy output file here:

${text(outputPath.theOutputPath.absolutePath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function portConflictForNoPort(error) {
  return fancyError("PORT CONFLICT", { tag: "NoLocation" })`
I ask the operating system for an arbitrary available port for the
web socket server.

The operating system is supposed to always be able to find an available port,
but it looks like that wasn't the case this time!

This is the error message I got:

${text(error.message)}
  `;
}
function portConflictForPersistedPort(elmWatchStuffJsonPath, port) {
  return fancyError("PORT CONFLICT", elmWatchStuffJsonPath)`
I ask the operating system for an arbitrary available port for the
web socket server.

I then save the port I got to ${elmWatchStuffJson}. Otherwise I would
get a new port number on each restart, which means that if you had tabs
open in the browser they would try to connect to the old port number.

I tried to use such a saved port number from a previous run (or from previous
configuration). But now that port (${number2(port.thePort)}) wasn't available!

Most likely you already have elm-watch running somewhere else! If so,
find it and use that, or kill it.

If not, something else could have started using port ${number2(port.thePort)}
(though it's not very likely.) Then you can either try to find what that is,
or remove ${elmWatchStuffJson} here:

${text(elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath)}

Then I will ask the operating system for a new arbitrary available port.
  `;
}
function portConflictForPortFromConfig(elmWatchJsonPath, port) {
  return fancyError("PORT CONFLICT", elmWatchJsonPath)`
In your ${elmWatchJson} you have this:

"port": ${json(port.thePort)}

But something else seems to already be running on that port!
You might already have elm-watch running somewhere, or it could be a completely
different program.

You need to either find and stop that other thing, switch to another port or
remove "port" from ${elmWatchJson} (which will use an arbitrary available port.)
  `;
}
function watcherError(error) {
  return fancyError("WATCHER ERROR", { tag: "NoLocation" })`
The file watcher encountered an error, which means that it cannot continue.
elm-watch is powered by its file watcher, so I have to exit at this point.

See if this is something you can solve by maybe removing some problematic files
or something!

This is the error message I got:

${text(error.message)}
  `;
}
function webSocketBadUrl(expectedStart, actualUrlString) {
  return `
I expected the web socket connection URL to start with:

${expectedStart}

But it looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here.
  `.trim();
}
function webSocketParamsDecodeError(error, actualUrlString) {
  return `
I ran into trouble parsing the web socket connection URL parameters:

${printJsonError(error).text}

The URL looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here. Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `;
}
function webSocketWrongVersion(expectedVersion, actualVersion) {
  return `
The compiled JavaScript code running in the browser says it was compiled with:

elm-watch ${actualVersion}

But the server is:

elm-watch ${expectedVersion}

Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `.trim();
}
function webSocketTargetNotFound(targetName, enabledOutputs, disabledOutputs) {
  const extra = isNonEmptyArray(disabledOutputs) ? `

These targets are also available in elm-watch.json, but are not enabled (because of the CLI arguments passed):

${join(
    mapNonEmptyArray(disabledOutputs, (outputPath) => outputPath.targetName),
    "\n"
  )}
  `.trimEnd() : "";
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

But I can't find that target in elm-watch.json!

These targets are available in elm-watch.json:

${join(
    enabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}${extra}

Maybe this target used to exist in elm-watch.json, but you removed or changed it?
If so, try reloading the page.
  `.trim();
}
function webSocketTargetDisabled(targetName, enabledOutputs, disabledOutputs) {
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

That target does exist in elm-watch.json, but isn't enabled.

These targets are enabled via CLI arguments:

${join(
    enabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}

These targets exist in elm-watch.json but aren't enabled:

${join(
    disabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}

If you want to have this target compiled, restart elm-watch either with more CLI arguments or no CLI arguments at all!
  `.trim();
}
function webSocketDecodeError(error) {
  return `
The compiled JavaScript code running in the browser seems to have sent a message that the web socket server cannot recognize!

${printJsonError(error).text}

The web socket code I generate is supposed to always send correct messages, so something is up here.
  `.trim();
}
function openEditorCommandFailed({
  error,
  command,
  cwd,
  timeout,
  env,
  stdout,
  stderr
}) {
  const errorReason = error.killed === true ? `The command took too long to run, and was killed after ${timeout} ms.` : error.code !== void 0 ? `The command exited with code ${error.code}.` : "The command failed for an unknown reason.";
  return `
I ran your command for opening an editor (set via the ${ELM_WATCH_OPEN_EDITOR} environment variable):

${commandToPresentationName(["cd", cwd.absolutePath])}
${command}

I ran the command with these extra environment variables:

${JSON.stringify(env, null, 2)}

${errorReason}

${printStdio(stdout, stderr)(DEFAULT_COLUMNS, (piece) => piece.text)}
  `.trim();
}
function printPATH(env, isWindows) {
  if (isWindows) {
    return printPATHWindows(env);
  }
  const { PATH } = env;
  if (PATH === void 0) {
    return template`I can't find any program, because process.env.PATH is undefined!`;
  }
  const pathList = PATH.split(path3.delimiter);
  return template`
This is what the PATH environment variable looks like:

${join3(pathList, "\n")}
  `;
}
function printPATHWindows(env) {
  const pathEntries = Object.entries(env).flatMap(
    ([key, value]) => key.toUpperCase() === "PATH" && value !== void 0 ? [[key, value]] : []
  );
  if (!isNonEmptyArray(pathEntries)) {
    return template`I can't find any program, because I can't find any PATH-like environment variables!`;
  }
  if (pathEntries.length === 1) {
    const [key, value] = pathEntries[0];
    return template`
This is what the ${text(key)} environment variable looks like:

${join3(value.split(path3.delimiter), "\n")}
    `;
  }
  const pathEntriesString = join3(
    pathEntries.map(
      ([key, value]) => join([`${key}:`, ...value.split(path3.delimiter)], "\n")
    ),
    "\n\n"
  );
  return template`
You seem to have several PATH-like environment variables set. The last one
should be the one that is actually used, but it's better to have a single one!

${pathEntriesString}
  `;
}
function printCommand(command) {
  const stdin = command.stdin === void 0 ? "" : `${commandToPresentationName([
    "printf",
    truncate(command.stdin.toString("utf8"))
  ])} | `;
  return text(`
${commandToPresentationName(["cd", command.options.cwd.absolutePath])}
${stdin}${commandToPresentationName([command.command, ...command.args])}
`);
}
function commandToPresentationName(command) {
  return join(
    command.map(
      (part) => part === "" ? "''" : join(
        part.split(/(')/).map(
          (subPart) => subPart === "" ? "" : subPart === "'" ? "\\'" : /^[\w.,:/=@%+-]+$/.test(subPart) ? subPart : `'${subPart}'`
        ),
        ""
      )
    ),
    " "
  );
}
function printExitReason(exitReason2) {
  switch (exitReason2.tag) {
    case "ExitCode":
      return text(`exit ${exitReason2.exitCode}`);
    case "Signal":
      return text(`signal ${exitReason2.signal}`);
    case "Unknown":
      return text("unknown exit reason");
  }
}
function printStdio(stdout, stderr) {
  return stdout !== "" && stderr === "" ? limitStdio(stdout) : stdout === "" && stderr !== "" ? limitStdio(stderr) : stdout === "" && stderr === "" ? template`${dim2("(no output)")}` : template`
STDOUT:
${limitStdio(stdout)}

STDERR:
${limitStdio(stderr)}
`;
}
function printElmWatchNodeStdio(stdout, stderr) {
  return stdout === "" && stderr === "" ? template`` : template`
STDOUT:
${limitStdio(stdout)}

STDERR:
${limitStdio(stderr)}
`;
}
var limitStdio = (string7) => (width, renderPiece) => {
  const max = 100;
  const lines = string7.trimEnd().split("\n");
  const result = [];
  let usedLines = 0;
  for (const line of lines) {
    const count = Math.ceil(line.length / width);
    const available = max - usedLines;
    if (available <= 0) {
      break;
    } else if (count > available) {
      const take = available * width;
      const left2 = line.length - take;
      result.push(
        `${line.slice(0, take)} ${renderPiece(
          dim2(left2 === 1 ? "1 more character" : `${left2} more characters`)
        )}`
      );
      usedLines += available;
      break;
    } else {
      result.push(line);
      usedLines += count;
    }
  }
  const joined = join(result, "\n");
  const left = lines.length - result.length;
  return left > 0 ? `${joined}
${renderPiece(
    dim2(left === 1 ? "1 more line" : `${left} more lines`)
  )}` : joined;
};
function printErrorFilePath(errorFilePath) {
  switch (errorFilePath.tag) {
    case "AbsolutePath":
      return template`
I wrote that to this file so you can inspect it:

${text(errorFilePath.absolutePath)}
      `;
    case "WritingErrorFileFailed":
      return template`
I tried to write that to this file:

${text(errorFilePath.attemptedPath.absolutePath)}

${bold2("But that failed too:")}

${text(errorFilePath.error.message)}
      `;
    case "ErrorFileBadContent":
      return template`
I wrote this error to a file so you can inspect and possibly report it more easily.

This is the data that caused the error:

${text(errorFilePath.content)}
      `;
  }
}
function printUnknownValueAsString(value) {
  switch (value.tag) {
    case "UnknownValueAsString":
      return text(value.value);
  }
}
function printElmWatchNodeImportCommand(scriptPath) {
  return template`const imported = await import(${json(
    scriptPath.theElmWatchNodeScriptFileUrl
  )})`;
}
function printElmWatchNodeRunCommand(args) {
  const truncated = {
    ...args,
    code: truncate(args.code)
  };
  return template`const result = await imported.default(${json(truncated, 2)})`;
}
function truncate(string7) {
  const roughLimit = 20;
  const half = Math.floor(roughLimit / 2);
  return string7.length <= roughLimit ? string7 : `${string7.slice(0, half)}...${string7.slice(-half)}`;
}
function printJsonError(error) {
  return text(error instanceof import_tiny_decoders2.DecoderError ? error.format() : error.message);
}
function tryWriteErrorFile({
  cwd,
  name,
  content,
  hash: hash3
}) {
  const jsonPath = absolutePathFromString(
    cwd,
    `elm-watch-${name}-${sha256(hash3)}.txt`
  );
  try {
    fs4.writeFileSync(jsonPath.absolutePath, content);
    return jsonPath;
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "WritingErrorFileFailed",
      error,
      attemptedPath: jsonPath
    };
  }
}
function sha256(string7) {
  return crypto.createHash("sha256").update(string7).digest("hex");
}

// src/HashSet.ts
var util2 = require("util");
var _a;
var HashSet = class {
  constructor(values) {
    this._set = /* @__PURE__ */ new Set();
    this[_a] = "HashSet";
    if (values !== void 0 && values !== null) {
      for (const value of values) {
        this._set.add(hash(value));
      }
    }
  }
  get size() {
    return this._set.size;
  }
  has(value) {
    return this._set.has(hash(value));
  }
  add(value) {
    this._set.add(hash(value));
    return this;
  }
  delete(value) {
    return this._set.delete(hash(value));
  }
  clear() {
    this._set.clear();
  }
  forEach(callback) {
    return callback;
  }
  *keys() {
    for (const value of this._set.keys()) {
      yield JSON.parse(value);
    }
  }
  values() {
    return this.keys();
  }
  *entries() {
    for (const value of this.keys()) {
      yield [value, value];
    }
  }
  [Symbol.iterator]() {
    return this.keys();
  }
  [(_a = Symbol.toStringTag, util2.inspect.custom)]() {
    return new Set(this);
  }
};
function hash(value) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a < b ? -1 : 1)
    )
  );
}

// src/ImportWalker.ts
var fs5 = require("fs");
var path4 = require("path");
var util3 = require("util");

// src/Parser.ts
var MODULE_NAME = /^\p{Lu}[_\d\p{L}]*(?:\.\p{Lu}[_\d\p{L}]*)*$/u;
var CR = 13;
var HYPHEN = 45;
var LEFT_BRACE = 123;
var LF = 10;
var RIGHT_BRACE = 125;
var SPACE = 32;
function isImport(chars) {
  return chars.length === 6 && chars[0] === 105 && chars[1] === 109 && chars[2] === 112 && chars[3] === 111 && chars[4] === 114 && chars[5] === 116;
}
var initialReadState = () => ({
  tokenizerState: { tag: "Initial", chars: [], multilineCommentLevel: 0 },
  parserState: { tag: "StartOfFile" },
  importedModules: []
});
function readChar(char, readState) {
  const maybeToken = tokenize(char, readState.tokenizerState);
  if (maybeToken === void 0) {
    return;
  }
  const maybeModuleName = parse2(maybeToken, readState.parserState);
  if (maybeModuleName !== void 0) {
    readState.importedModules.push(maybeModuleName);
  }
}
function isNonImport(readState) {
  return readState.parserState.tag === "NonImport";
}
function finalize(readState) {
  if (readState.tokenizerState.tag !== "Initial") {
    return readState.importedModules;
  }
  const maybeLastToken = flush(readState.tokenizerState.chars);
  if (maybeLastToken === void 0) {
    return readState.importedModules;
  }
  const maybeLastModuleName = parse2(maybeLastToken, readState.parserState);
  if (maybeLastModuleName === void 0) {
    return readState.importedModules;
  }
  readState.importedModules.push(maybeLastModuleName);
  return readState.importedModules;
}
function tokenize(char, tokenizerState) {
  switch (tokenizerState.tag) {
    case "Initial":
      switch (char) {
        case SPACE: {
          const maybeToken = flush(tokenizerState.chars);
          tokenizerState.chars = [];
          return maybeToken;
        }
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return flush(tokenizerState.chars);
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return flush(tokenizerState.chars);
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return flush(tokenizerState.chars);
        default:
          tokenizerState.chars.push(char);
          return void 0;
      }
    case "MaybeNewChunk":
      switch (char) {
        case SPACE:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [];
          return void 0;
        case CR:
        case LF:
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [char];
          return { tag: "NewChunk" };
      }
    case "MaybeMultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel = 1;
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [LEFT_BRACE];
          return tokenize(char, tokenizerState);
      }
    case "MultilineComment":
      switch (char) {
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MultilineComment-";
          return void 0;
        default:
          return void 0;
      }
    case "MultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel++;
          return void 0;
        case LEFT_BRACE:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MultilineComment-":
      switch (char) {
        case RIGHT_BRACE:
          if (tokenizerState.multilineCommentLevel <= 1) {
            tokenizerState.tag = "Initial";
            tokenizerState.chars = [];
          } else {
            tokenizerState.tag = "MultilineComment";
            tokenizerState.multilineCommentLevel--;
          }
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MaybeSinglelineComment-":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "SinglelineComment";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [HYPHEN];
          return tokenize(char, tokenizerState);
      }
    case "SinglelineComment":
      switch (char) {
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return void 0;
        default:
          return void 0;
      }
  }
}
function flush(chars) {
  return isNonEmptyArray(chars) ? { tag: "Word", chars } : void 0;
}
function parse2(token, parserState) {
  switch (parserState.tag) {
    case "StartOfFile":
      switch (token.tag) {
        case "NewChunk":
          return void 0;
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
      }
    case "NewChunk":
      switch (token.tag) {
        case "NewChunk":
          return void 0;
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "NonImport";
            return void 0;
          }
      }
    case "Import":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word": {
          const string7 = Buffer.from(token.chars).toString();
          if (MODULE_NAME.test(string7)) {
            parserState.tag = "Ignore";
            return split(string7, ".");
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
        }
      }
    case "Ignore":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word":
          return void 0;
      }
    case "NonImport":
      return void 0;
  }
}

// src/ImportWalker.ts
function walkImports(sourceDirectories, inputPaths) {
  const allRelatedElmFilePaths = new Set(
    inputPaths.flatMap(
      (inputPath) => initialRelatedElmFilePaths(sourceDirectories, inputPath)
    )
  );
  allRelatedElmFilePaths[util3.inspect.custom] = () => Array.from(allRelatedElmFilePaths);
  const visitedModules = /* @__PURE__ */ new Set();
  try {
    for (const inputPath of inputPaths) {
      walkImportsHelper(
        mapNonEmptyArray(sourceDirectories, (sourceDirectory) => ({
          sourceDirectory,
          children: new Set(readdirSync2(sourceDirectory.theSourceDirectory))
        })),
        inputPath.realpath.absolutePath,
        allRelatedElmFilePaths,
        visitedModules
      );
    }
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ImportWalkerFileSystemError",
      error,
      relatedElmFilePathsUntilError: allRelatedElmFilePaths
    };
  }
  return { tag: "Success", allRelatedElmFilePaths };
}
function walkImportsHelper(sourceDirectories, elmFilePath, allRelatedElmFilePaths, visitedModules) {
  if (!fs5.existsSync(elmFilePath)) {
    return;
  }
  const importedModules = parse3(elmFilePath);
  for (const importedModule of importedModules) {
    const relativePath = `${importedModule.join(path4.sep)}.elm`;
    if (!visitedModules.has(relativePath)) {
      visitedModules.add(relativePath);
      for (const { sourceDirectory, children } of sourceDirectories) {
        const newElmFilePath = sourceDirectory.theSourceDirectory.absolutePath + path4.sep + relativePath;
        allRelatedElmFilePaths.add(newElmFilePath);
        const child = importedModule.length === 1 ? `${importedModule[0]}.elm` : importedModule[0];
        if (children.has(child)) {
          walkImportsHelper(
            sourceDirectories,
            newElmFilePath,
            allRelatedElmFilePaths,
            visitedModules
          );
        }
      }
    }
  }
}
function parse3(elmFilePath) {
  const readState = initialReadState();
  const handle = fs5.openSync(elmFilePath, "r");
  const buffer = Buffer.alloc(2048);
  let bytesRead = 0;
  outer:
    while ((bytesRead = fs5.readSync(handle, buffer)) > 0) {
      for (const char of buffer.slice(0, bytesRead)) {
        readChar(char, readState);
        if (isNonImport(readState)) {
          break outer;
        }
      }
    }
  fs5.closeSync(handle);
  return finalize(readState);
}
function initialRelatedElmFilePaths(sourceDirectories, inputPath) {
  const inputPathString = inputPath.realpath.absolutePath;
  return [
    inputPathString,
    ...sourceDirectories.flatMap((sourceDirectory) => {
      const prefix = sourceDirectory.theSourceDirectory.absolutePath + path4.sep;
      return inputPathString.startsWith(prefix) ? sourceDirectories.map(
        (sourceDirectory2) => sourceDirectory2.theSourceDirectory.absolutePath + path4.sep + inputPathString.slice(prefix.length)
      ) : [];
    })
  ];
}
function readdirSync2(dir) {
  try {
    return fs5.readdirSync(dir.absolutePath);
  } catch {
    return [];
  }
}

// src/Inject.ts
var ClientCode = require("./ClientCode");
var REPLACEMENT_REGEX = /^(?:function (F|_Platform_initialize|_Platform_export|_Browser_application|_Scheduler_binding|_Scheduler_step)\(|var (_VirtualDom_init|\$elm\$browser\$Browser\$sandbox|_Platform_worker|_Browser_element|_Browser_document|_Debugger_element|_Debugger_document) =).*\r?\n?\{(?:.*\r?\n)*?\}\)?;?$/gm;
var PLACEHOLDER_REGEX = /%(\w+)%/g;
var REPLACEMENTS = {
  _Platform_initialize: `
// This whole function was changed by elm-watch.
function _Platform_initialize(programType, isDebug, debugMetadata, flagDecoder, args, init, impl, stepperBuilder)
{
	if (args === "__elmWatchReturnData") {
		return { impl: impl, debugMetadata: debugMetadata, flagDecoder : flagDecoder, programType: programType };
	}

	var flags = _Json_wrap(args ? args['flags'] : undefined);
	var flagResult = A2(_Json_run, flagDecoder, flags);
	$elm$core$Result$isOk(flagResult) || _Debug_crash(2 /**/, _Json_errorToString(flagResult.a) /**/);
	var managers = {};
	var initUrl = programType === "Browser.application" ? _Browser_getUrl() : undefined;
	globalThis.__ELM_WATCH.INIT_URL = initUrl;
	var initPair = init(flagResult.a);
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);
	var update;
	var subscriptions;

	function setUpdateAndSubscriptions() {
		update = impl.%update% || impl._impl.%update%;
		subscriptions = impl.%subscriptions% || impl._impl.%subscriptions%;
		if (isDebug) {
			update = $elm$browser$Debugger$Main$wrapUpdate(update);
			subscriptions = $elm$browser$Debugger$Main$wrapSubs(subscriptions);
		}
	}

	function sendToApp(msg, viewMetadata) {
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	setUpdateAndSubscriptions();
	_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));

	function __elmWatchHotReload(newData, new_Platform_effectManagers, new_Scheduler_enqueue, moduleName) {
		_Platform_enqueueEffects(managers, _Platform_batch(_List_Nil), _Platform_batch(_List_Nil));
		_Scheduler_enqueue = new_Scheduler_enqueue;

		var reloadReasons = [];

		for (var key in new_Platform_effectManagers) {
			var manager = new_Platform_effectManagers[key];
			if (!(key in _Platform_effectManagers)) {
				_Platform_effectManagers[key] = manager;
				managers[key] = _Platform_instantiateManager(manager, sendToApp);
				if (manager.a) {
					reloadReasons.push("a new port '" + key + "' was added. The idea is to give JavaScript code a chance to set it up!");
					manager.a(key, sendToApp)
				}
			}
		}

		for (var key in newData.impl) {
			if (key === "_impl" && impl._impl) {
				for (var subKey in newData.impl[key]) {
					impl._impl[subKey] = newData.impl[key][subKey];
				}
			} else {
				impl[key] = newData.impl[key];
			}
		}

		var newFlagResult = A2(_Json_run, newData.flagDecoder, flags);
		if (!$elm$core$Result$isOk(newFlagResult)) {
			return reloadReasons.concat("the flags type in \`" + moduleName + "\` changed and now the passed flags aren't correct anymore. The idea is to try to run with new flags!\\nThis is the error:\\n" + _Json_errorToString(newFlagResult.a));
		}
		if (!_Utils_eq_elmWatchInternal(debugMetadata, newData.debugMetadata)) {
			return reloadReasons.concat("the message type in \`" + moduleName + '\` changed in debug mode ("debug metadata" changed).');
		}
		init = impl.%init% || impl._impl.%init%;
		if (isDebug) {
			init = A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(newData.debugMetadata), initPair.a.popout, init);
		}
		globalThis.__ELM_WATCH.INIT_URL = initUrl;
		var newInitPair = init(newFlagResult.a);
		if (!_Utils_eq_elmWatchInternal(initPair, newInitPair)) {
			return reloadReasons.concat("\`" + moduleName + ".init\` returned something different than last time. Let's start fresh!");
		}

		setUpdateAndSubscriptions();
		stepper(model, true /* isSync */);
		_Platform_enqueueEffects(managers, _Platform_batch(_List_Nil), subscriptions(model));
		return reloadReasons;
	}

	return Object.defineProperties(
		ports ? { ports: ports } : {},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchProgramType: { value: programType },
		}
	);
}

// This whole function was added by elm-watch.
// Copy-paste of _Utils_eq but does not assume that x and y have the same type,
// and considers functions to always be equal.
function _Utils_eq_elmWatchInternal(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp_elmWatchInternal(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp_elmWatchInternal(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

// This whole function was added by elm-watch.
function _Utils_eqHelp_elmWatchInternal(x, y, depth, stack)
{
	if (x === y) {
		return true;
	}

	var xType = _Utils_typeof_elmWatchInternal(x);
	var yType = _Utils_typeof_elmWatchInternal(y);

	if (xType !== yType) {
		return false;
	}

	switch (xType) {
		case "primitive":
			return false;
		case "function":
			return true;
	}

	if (x.$ !== y.$) {
		return false;
	}

	if (x.$ === 'Set_elm_builtin') {
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	} else if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin' || x.$ < 0) {
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}

	if (Object.keys(x).length !== Object.keys(y).length) {
		return false;
	}

	if (depth > 100) {
		stack.push(_Utils_Tuple2(x, y));
		return true;
	}

	for (var key in x) {
		if (!_Utils_eqHelp_elmWatchInternal(x[key], y[key], depth + 1, stack)) {
			return false;
		}
	}
	return true;
}

// This whole function was added by elm-watch.
function _Utils_typeof_elmWatchInternal(x)
{
	var type = typeof x;
	return type === "function"
		? "function"
		: type !== "object" || type === null
		? "primitive"
		: "objectOrArray";
}
				`.trim(),
  F: `
var _Platform_effectManagers = {}, _Scheduler_enqueue; // added by elm-watch

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}
  `.trim(),
  _VirtualDom_init: `
// This whole function was changed by elm-watch.
var _VirtualDom_init = F4(function(virtualNode, flagDecoder, debugMetadata, args)
{
	var programType = "Html";

	if (args === "__elmWatchReturnData") {
		return { virtualNode: virtualNode, programType: programType };
	}

	/**_UNUSED/ // always UNUSED with elm-watch
	var node = args['node'];
	//*/
	/**/
	var node = args && args['node'] ? args['node'] : _Debug_crash(0);
	//*/

	var nextNode = _VirtualDom_render(virtualNode, function() {});
	node.parentNode.replaceChild(nextNode, node);
	node = nextNode;
	var sendToApp = function() {};

	function __elmWatchHotReload(newData) {
		var patches = _VirtualDom_diff(virtualNode, newData.virtualNode);
		node = _VirtualDom_applyPatches(node, virtualNode, patches, sendToApp);
		virtualNode = newData.virtualNode;
		return [];
	}

	return Object.defineProperties(
		{},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchProgramType: { value: programType },
		}
	);
});
				`.trim(),
  _Platform_export: `
// This whole function was changed by elm-watch.
function _Platform_export(exports)
{
	var reloadReasons = _Platform_mergeExportsElmWatch('Elm', scope['Elm'] || (scope['Elm'] = {}), exports);
	if (reloadReasons.length > 0) {
		throw new Error(["ELM_WATCH_RELOAD_NEEDED"].concat(Array.from(new Set(reloadReasons))).join("\\n\\n---\\n\\n"));
	}
}

// This whole function was added by elm-watch.
function _Platform_mergeExportsElmWatch(moduleName, obj, exports)
{
	var reloadReasons = [];
	for (var name in exports) {
		if (name === "init") {
			if ("init" in obj) {
				if ("__elmWatchApps" in obj) {
					var data = exports.init("__elmWatchReturnData");
					for (var index = 0; index < obj.__elmWatchApps.length; index++) {
						var app = obj.__elmWatchApps[index];
						if (app.__elmWatchProgramType !== data.programType) {
							reloadReasons.push("\`" + moduleName + ".main\` changed from \`" + app.__elmWatchProgramType + "\` to \`" + data.programType + "\`.");
						} else {
							try {
								var innerReasons = app.__elmWatchHotReload(data, _Platform_effectManagers, _Scheduler_enqueue, moduleName);
								reloadReasons = reloadReasons.concat(innerReasons);
							} catch (error) {
								reloadReasons.push("hot reload for \`" + moduleName + "\` failed, probably because of incompatible model changes.\\nThis is the error:\\n" + error + "\\n" + (error ? error.stack : ""));
							}
						}
					}
				} else {
					throw new Error("elm-watch: I'm trying to create \`" + moduleName + ".init\`, but it already exists and wasn't created by elm-watch. Maybe a duplicate script is getting loaded accidentally?");
				}
			} else {
				obj.__elmWatchApps = [];
				obj.init = function() {
					var app = exports.init.apply(exports, arguments);
					obj.__elmWatchApps.push(app);
					globalThis.__ELM_WATCH.ON_INIT();
					return app;
				};
			}
		} else {
			var innerReasons = _Platform_mergeExportsElmWatch(moduleName + "." + name, obj[name] || (obj[name] = {}), exports[name]);
			reloadReasons = reloadReasons.concat(innerReasons);
		}
	}
	return reloadReasons;
}
				`.trim(),
  _Browser_application: `
// This function was slightly modified by elm-watch.
function _Browser_application(impl)
{
	// var onUrlChange = impl.onUrlChange; // commented out by elm-watch
	// var onUrlRequest = impl.onUrlRequest; // commented out by elm-watch
	// var key = function() { key.a(onUrlChange(_Browser_getUrl())); }; // commented out by elm-watch
	var key = function() { key.a(impl.%onUrlChange%(_Browser_getUrl())); }; // added by elm-watch

	return _Browser_document({
		%setup%: function(sendToApp)
		{
			key.a = sendToApp;
			_Browser_window.addEventListener('popstate', key);
			_Browser_window.navigator.userAgent.indexOf('Trident') < 0 || _Browser_window.addEventListener('hashchange', key);

			return F2(function(domNode, event)
			{
				if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute('download'))
				{
					event.preventDefault();
					var href = domNode.href;
					var curr = _Browser_getUrl();
					var next = $elm$url$Url$fromString(href).a;
					sendToApp(impl.%onUrlRequest%(
						(next
							&& curr.%protocol% === next.%protocol%
							&& curr.%host% === next.%host%
							&& curr.%port_%.a === next.%port_%.a
						)
							? $elm$browser$Browser$Internal(next)
							: $elm$browser$Browser$External(href)
					));
				}
			});
		},
		%init%: function(flags)
		{
			// return A3(impl.init, flags, _Browser_getUrl(), key); // commented out by elm-watch
			return A3(impl.%init%, flags, globalThis.__ELM_WATCH.INIT_URL, key); // added by elm-watch
		},
		// view: impl.view, // commented out by elm-watch
		// update: impl.update, // commented out by elm-watch
		// subscriptions: impl.subscriptions // commented out by elm-watch
		%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
		_impl: impl // added by elm-watch
	});
}
  `.trim(),
  $elm$browser$Browser$sandbox: `
// This function was slightly modified by elm-watch.
var $elm$browser$Browser$sandbox = function (impl) {
	return _Browser_element(
		{
			%init%: function (_v0) {
				return _Utils_Tuple2(impl.%init%, $elm$core$Platform$Cmd$none);
			},
			%subscriptions%: function (_v1) {
				return $elm$core$Platform$Sub$none;
			},
			%update%: F2(
				function (msg, model) {
					return _Utils_Tuple2(
						A2(impl.%update%, msg, model),
						$elm$core$Platform$Cmd$none);
				}),
			// view: impl.view // commented out by elm-watch
			%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
			_impl: impl // added by elm-watch
		});
};
  `.trim(),
  _Platform_worker: `
// This function was slightly modified by elm-watch.
var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		"Platform.worker", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function() { return function() {} }
	);
});
  `.trim(),
  _Browser_element: `
// This function was slightly modified by elm-watch.
var _Browser_element = _Debugger_element || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			// var view = impl.view; // commented out by elm-watch
			/**_UNUSED/ // always UNUSED with elm-watch
			var domNode = args['node'];
			//*/
			/**/
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			//*/
			var currNode = _VirtualDom_virtualize(domNode);

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = view(model); // commented out by elm-watch
				var nextNode = impl.%view%(model); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;
			});
		}
	);
});
  `.trim(),
  _Browser_document: `
// This function was slightly modified by elm-watch.
var _Browser_document = _Debugger_document || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			var divertHrefToApp = impl.%setup% && impl.%setup%(sendToApp)
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			var currNode = _VirtualDom_virtualize(bodyNode);
			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view(model); // commented out by elm-watch
				var doc = impl.%view%(model); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(doc.%body%);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.%title%) && (_VirtualDom_doc.title = title = doc.%title%);
			});
		}
	);
});
  `.trim(),
  _Debugger_element: `
// This function was slightly modified by elm-watch.
var _Debugger_element = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		true, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			var currNode = _VirtualDom_virtualize(domNode);
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			var cornerNode = _VirtualDom_doc.createElement('div');
			domNode.parentNode.insertBefore(cornerNode, domNode.nextSibling);
			var cornerCurr = _VirtualDom_virtualize(cornerNode);

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, view($elm$browser$Debugger$Main$getUserModel(model))); // commented out by elm-watch
				var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, impl.view($elm$browser$Debugger$Main$getUserModel(model))); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view corner

				var cornerNext = $elm$browser$Debugger$Main$cornerView(model);
				var cornerPatches = _VirtualDom_diff(cornerCurr, cornerNext);
				cornerNode = _VirtualDom_applyPatches(cornerNode, cornerCurr, cornerPatches, sendToApp);
				cornerCurr = cornerNext;

				if (!model.popout.b)
				{
					currPopout = undefined;
					return;
				}

				// view popout

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  _Debugger_document: `
// This function was slightly modified by elm-watch.
var _Debugger_document = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		true, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			var divertHrefToApp = impl.setup && impl.setup(function(x) { return sendToApp($elm$browser$Debugger$Main$UserMsg(x)); });
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			var currNode = _VirtualDom_virtualize(bodyNode);
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view($elm$browser$Debugger$Main$getUserModel(model)); // commented out by elm-watch
				var doc = impl.view($elm$browser$Debugger$Main$getUserModel(model)); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(
					_Utils_ap(
						A2($elm$core$List$map, _VirtualDom_map($elm$browser$Debugger$Main$UserMsg), doc.body),
						_List_Cons($elm$browser$Debugger$Main$cornerView(model), _List_Nil)
					)
				);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.title) && (_VirtualDom_doc.title = title = doc.title);

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view popout

				if (!model.popout.b) { currPopout = undefined; return; }

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  _Scheduler_binding: `
// This function was slightly modified by elm-watch.
function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		// c: null // commented out by elm-watch
		c: Function.prototype // added by elm-watch
	};
}
  `.trim(),
  _Scheduler_step: `
function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			// }); // commented out by elm-watch
			}) || Function.prototype; // added by elm-watch
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}
  `.trim()
};
var REPLACEMENTS_WITHOUT_PLACEHOLDERS = updateReplacements({}, REPLACEMENTS);
function inject(compilationMode, code) {
  const replacements = getReplacements(compilationMode, code);
  return code.replace(
    REPLACEMENT_REGEX,
    (match, name1, name = name1) => replacements[name] ?? `${match} /* elm-watch ERROR: No replacement for function '${name}' was found! */`
  );
}
function getReplacements(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return REPLACEMENTS_WITHOUT_PLACEHOLDERS;
    case "optimize":
      return updateReplacements(getOptimizeModeRecordNames(code), REPLACEMENTS);
  }
}
function getOptimizeModeRecordNames(code) {
  const match1 = /^\s*impl\.([\w$]+),\s*impl\.([\w$]+),\s*impl\.([\w$]+),/m.exec(code);
  const match2 = /^\s*var divertHrefToApp = impl\.([\w$]+)/m.exec(code);
  const match3 = /^\s*var nextNode = _VirtualDom_node\('body'\)\(_List_Nil\)\(doc\.([\w$]+)\);/m.exec(
    code
  );
  const match4 = /^\s*\(title !== doc\.([\w$]+)\)/m.exec(code);
  const match5 = /^\s*&& curr\.([\w$]+) .*\s*&& curr\.([\w$]+) .*\s*&& curr\.([\w$]+)\..*/m.exec(
    code
  );
  const [
    ,
    init3 = "init_missing",
    update2 = "update_missing",
    subscriptions = "subscriptions_missing"
  ] = match1 ?? [];
  const [, setup = "setup_missing"] = match2 ?? [];
  const [, body = "body_missing"] = match3 ?? [];
  const [, title = "title_missing"] = match4 ?? [];
  const [
    ,
    protocol = "protocol_missing",
    host = "host_missing",
    port_ = "port__missing"
  ] = match5 ?? [];
  const extra = Object.fromEntries(
    Array.from(
      code.matchAll(/^\s*var ([\w$]+) = impl\.([\w$]+);/gm),
      ([, from = "from_missing", to = "to_missing"]) => [from, to]
    )
  );
  return {
    ...extra,
    init: init3,
    update: update2,
    subscriptions,
    setup,
    body,
    title,
    protocol,
    host,
    port_
  };
}
function updateReplacements(optimizeModeRecordNames, replacements) {
  return Object.fromEntries(
    Object.entries(replacements).map(([key, value]) => [
      key,
      updateString(optimizeModeRecordNames, value)
    ])
  );
}
function updateString(optimizeModeRecordNames, string7) {
  return string7.replace(
    PLACEHOLDER_REGEX,
    (_, name) => optimizeModeRecordNames[name] ?? name
  );
}
function proxyFile(outputPath, elmCompiledTimestamp, browserUiPosition, webSocketPort, debug) {
  return `${clientCode(
    outputPath,
    elmCompiledTimestamp,
    "proxy",
    browserUiPosition,
    webSocketPort,
    debug
  )}
${ClientCode.proxy}`;
}
function clientCode(outputPath, elmCompiledTimestamp, compilationMode, browserUiPosition, webSocketPort, debug) {
  const replacements = {
    TARGET_NAME: outputPath.targetName,
    INITIAL_ELM_COMPILED_TIMESTAMP: elmCompiledTimestamp.toString(),
    ORIGINAL_COMPILATION_MODE: compilationMode,
    ORIGINAL_BROWSER_UI_POSITION: browserUiPosition,
    WEBSOCKET_PORT: webSocketPort.thePort.toString(),
    DEBUG: debug.toString()
  };
  return versionedIdentifier(outputPath.targetName, webSocketPort) + ClientCode.client.replace(
    new RegExp(`%(${join(Object.keys(replacements), "|")})%`, "g"),
    (match, name) => replacements[name] ?? match
  );
}
function versionedIdentifier(targetName, webSocketPort) {
  return `// elm-watch hot ${JSON.stringify({
    version: "1.1.2",
    targetName,
    webSocketPort: webSocketPort.thePort
  })}
`;
}
var RECORD_FIELD_REGEX = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?|\/\*(?:[^*]|\*(?!\/))*(\*\/)?|\/\/.*|\.[\w$]{1,4}\b/g;
function getRecordFields(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return void 0;
    case "optimize": {
      const matches = code.match(RECORD_FIELD_REGEX) ?? [];
      return new Set(matches.filter((string7) => string7.startsWith(".")));
    }
  }
}
function recordFieldsChanged(oldSet, newSet) {
  return !(oldSet === void 0 || newSet === void 0 || compareRecordFieldsHelper(oldSet) === compareRecordFieldsHelper(newSet));
}
function compareRecordFieldsHelper(set) {
  return Array.from(set).sort().join(",");
}

// src/Postprocess.ts
var path5 = require("path");
var import_worker_threads = require("worker_threads");

// src/Spawn.ts
var childProcess = require("child_process");
function spawn2(command) {
  let killed = false;
  let kill = () => {
    killed = true;
  };
  const promise = (actualSpawn) => new Promise((resolve3) => {
    if (killed) {
      resolve3({ tag: "Killed", command });
      return;
    }
    const child = actualSpawn(command.command, command.args, {
      ...command.options,
      cwd: command.options.cwd.absolutePath
    });
    const stdout = [];
    const stderr = [];
    child.on("error", (error) => {
      resolve3(
        error.code === "ENOENT" ? { tag: "CommandNotFoundError", command } : { tag: "OtherSpawnError", error, command }
      );
    });
    let stdinWriteError = void 0;
    child.stdin.on("error", (error) => {
      if (error.code === "EPIPE" || error.code === "EOF") {
        const result = {
          tag: "StdinWriteError",
          error,
          command
        };
        stdinWriteError = {
          result,
          timeoutId: setTimeout(
            () => {
              resolve3(result);
            },
            500
          )
        };
      } else {
        resolve3({ tag: "OtherSpawnError", error, command });
      }
    });
    child.stdout.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stderr.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    child.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    child.on("exit", (exitCode, signal) => {
      if (killed) {
      } else if (exitCode === 0 && stdinWriteError !== void 0) {
        clearTimeout(stdinWriteError.timeoutId);
        resolve3(stdinWriteError.result);
      } else {
        resolve3({
          tag: "Exit",
          exitReason: exitReason(exitCode, signal),
          stdout: Buffer.concat(stdout),
          stderr: Buffer.concat(stderr),
          command
        });
      }
    });
    kill = () => {
      if (!killed) {
        child.kill();
        resolve3({ tag: "Killed", command });
        killed = true;
      }
    };
    if (command.stdin !== void 0) {
      child.stdin.end(command.stdin);
    }
  });
  return {
    promise: IS_WINDOWS ? import("cross-spawn").then((crossSpawn) => promise(crossSpawn.spawn)) : promise(childProcess.spawn),
    kill: () => {
      kill();
    }
  };
}
function exitReason(exitCode, signal) {
  return exitCode !== null ? { tag: "ExitCode", exitCode } : signal !== null ? { tag: "Signal", signal } : { tag: "Unknown" };
}

// src/Postprocess.ts
function runPostprocess({
  env,
  elmWatchJsonPath,
  compilationMode,
  runMode,
  outputPath: output,
  postprocessArray,
  code,
  postprocessWorkerPool
}) {
  const commandName = postprocessArray[0];
  const userArgs = postprocessArray.slice(1);
  const cwd = absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath);
  if (commandName === ELM_WATCH_NODE) {
    const worker = postprocessWorkerPool.getOrCreateAvailableWorker();
    return {
      promise: worker.postprocess({
        cwd,
        code: code.toString("utf8"),
        targetName: output.targetName,
        compilationMode,
        runMode,
        userArgs
      }),
      kill: () => worker.terminate()
    };
  }
  const command = {
    command: commandName,
    args: [...userArgs, output.targetName, compilationMode, runMode],
    options: { cwd, env },
    stdin: code
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
      case "OtherSpawnError":
        return spawnResult;
      case "StdinWriteError":
        return {
          tag: "PostprocessStdinWriteError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        if (!(exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0)) {
          const stdout = spawnResult.stdout.toString("utf8");
          const stderr = spawnResult.stderr.toString("utf8");
          return {
            tag: "PostprocessNonZeroExit",
            exitReason: exitReason2,
            stdout,
            stderr,
            command
          };
        }
        return { tag: "Success", code: spawnResult.stdout };
      }
    }
  };
  return {
    promise: promise.then(handleSpawnResult),
    kill: () => {
      kill();
      return Promise.resolve();
    }
  };
}
var PostprocessWorkerPool = class {
  constructor(onUnexpectedError) {
    this.onUnexpectedError = onUnexpectedError;
    this.workers = /* @__PURE__ */ new Set();
    this.calculateMax = () => Infinity;
  }
  getSize() {
    return this.workers.size;
  }
  setCalculateMax(calculateMax) {
    this.calculateMax = calculateMax;
  }
  getOrCreateAvailableWorker() {
    const existingWorker = Array.from(this.workers).find(
      (worker) => worker.isIdle()
    );
    if (existingWorker === void 0) {
      const newWorker = new PostprocessWorker(
        this.onUnexpectedError,
        () => {
          this.limit().catch(this.onUnexpectedError);
        },
        (worker) => {
          this.workers.delete(worker);
        }
      );
      this.workers.add(newWorker);
      return newWorker;
    } else {
      return existingWorker;
    }
  }
  async limit() {
    const idle = Array.from(this.workers).filter((worker) => worker.isIdle());
    const toKill = this.workers.size - this.calculateMax();
    if (toKill > 0) {
      await Promise.all(
        idle.slice(-toKill).map((worker) => worker.terminate())
      );
    }
    return toKill;
  }
  async terminate() {
    await Promise.all(
      Array.from(this.workers).map((worker) => worker.terminate())
    );
  }
};
var PostprocessWorker = class {
  constructor(onUnexpectedError, onIdle, onTerminated) {
    this.onUnexpectedError = onUnexpectedError;
    this.onIdle = onIdle;
    this.onTerminated = onTerminated;
    this.worker = new import_worker_threads.Worker(path5.join(__dirname, "PostprocessWorker.js"), {
      stdout: true,
      stderr: true
    });
    this.status = { tag: "Idle" };
    const stdout = [];
    const stderr = [];
    this.worker.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    this.worker.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    this.worker.on("error", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("messageerror", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("exit", (exitCode) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(
          new Error(
            `PostprocessWorker unexpectedly exited, with exit code ${exitCode}.`
          )
        );
      }
    });
    this.worker.on("message", (message) => {
      switch (message.tag) {
        case "PostprocessDone":
          switch (this.status.tag) {
            case "Idle":
              this.terminate().catch(this.onUnexpectedError);
              this.onUnexpectedError(
                new Error(
                  `PostprocessWorker received a ${JSON.stringify(
                    message.tag
                  )} message from the worker. This should only happen when "Busy" but the status is "Idle".`
                )
              );
              break;
            case "Busy":
              switch (message.result.tag) {
                case "Resolve": {
                  const result = message.result.value;
                  this.status.resolve(
                    "stdout" in result ? {
                      ...result,
                      stdout: Buffer.concat(stdout).toString("utf8"),
                      stderr: Buffer.concat(stderr).toString("utf8")
                    } : result
                  );
                  break;
                }
                case "Reject":
                  this.status.reject(toError(message.result.error));
                  break;
              }
              this.status = { tag: "Idle" };
              this.onIdle(this);
              break;
            case "Terminated":
              break;
          }
          stdout.length = 0;
          stderr.length = 0;
      }
    });
  }
  postMessage(message) {
    this.worker.postMessage(message);
  }
  isIdle() {
    return this.status.tag === "Idle";
  }
  async postprocess(args) {
    switch (this.status.tag) {
      case "Idle":
        return new Promise((resolve3, reject) => {
          this.status = { tag: "Busy", resolve: resolve3, reject };
          this.postMessage({ tag: "StartPostprocess", args });
        });
      case "Busy":
      case "Terminated":
        throw new Error(
          `Cannot call PostprocessWorker#postprocess because \`this.status === ${JSON.stringify(
            this.status
          )}\` instead of the expected "Idle".`
        );
    }
  }
  async terminate() {
    switch (this.status.tag) {
      case "Idle":
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        break;
      case "Busy": {
        const { resolve: resolve3 } = this.status;
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        resolve3({ tag: "Killed" });
        break;
      }
      case "Terminated":
    }
  }
};

// src/SpawnElm.ts
var fs6 = require("fs");
var os2 = require("os");

// src/ElmMakeError.ts
var Decode5 = require("tiny-decoders");
var Color = Decode5.stringUnion({
  red: null,
  RED: null,
  magenta: null,
  MAGENTA: null,
  yellow: null,
  YELLOW: null,
  green: null,
  GREEN: null,
  cyan: null,
  CYAN: null,
  blue: null,
  BLUE: null,
  black: null,
  BLACK: null,
  white: null,
  WHITE: null
});
var MessageChunk = Decode5.multi({
  string: (string7) => ({
    tag: "UnstyledText",
    string: string7
  }),
  object: Decode5.fieldsAuto({
    tag: () => "StyledText",
    bold: Decode5.boolean,
    underline: Decode5.boolean,
    color: Decode5.nullable(Color, void 0),
    string: Decode5.string
  })
});
var Position = Decode5.fieldsAuto({
  line: Decode5.number,
  column: Decode5.number
});
var Region = Decode5.fieldsAuto({
  start: Position,
  end: Position
});
var Problem = Decode5.fieldsAuto({
  title: Decode5.string,
  region: Region,
  message: Decode5.array(MessageChunk)
});
var CompileError = Decode5.fieldsAuto({
  path: Decode5.chain(
    Decode5.string,
    (string7) => ({
      tag: "AbsolutePath",
      absolutePath: string7
    })
  ),
  name: Decode5.string,
  problems: NonEmptyArray(Problem)
});
var GeneralError = Decode5.fieldsAuto({
  tag: () => "GeneralError",
  path: Decode5.nullable(
    Decode5.chain(
      Decode5.stringUnion({
        "elm.json": null
      }),
      (tag) => ({ tag })
    ),
    { tag: "NoPath" }
  ),
  title: Decode5.string,
  message: Decode5.array(MessageChunk)
});
var ElmMakeError = Decode5.fieldsUnion("type", {
  error: GeneralError,
  "compile-errors": Decode5.fieldsAuto({
    tag: () => "CompileErrors",
    errors: NonEmptyArray(CompileError)
  })
});

// src/SpawnElm.ts
function make({
  elmJsonPath,
  compilationMode,
  inputs,
  outputPath,
  env,
  getNow
}) {
  const command = {
    command: "elm",
    args: [
      "make",
      "--report=json",
      ...maybeToArray(compilationModeToArg(compilationMode)),
      `--output=${outputPathToAbsoluteString(outputPath)}`,
      ...inputs.map((inputPath) => inputPath.theInputPath.absolutePath)
    ],
    options: {
      cwd: absoluteDirname(elmJsonPath.theElmJsonPath),
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        const unexpectedElmMakeOutput2 = {
          tag: "UnexpectedElmMakeOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
        return exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stdout === "" && stderr === "" ? { tag: "Success" } : exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && stdout === "" ? parsePotentialElmMakeJson(command, stderr) ?? unexpectedElmMakeOutput2 : unexpectedElmMakeOutput2;
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: ({ force }) => {
      if (force) {
        kill();
      } else {
        delayKill(promise, startTime, getNow, env, kill);
      }
    }
  };
}
function delayKill(promise, startTime, getNow, env, kill) {
  const timeout = silentlyReadIntEnvValue(
    env[__ELM_WATCH_ELM_TIMEOUT_MS],
    1e4
  );
  const elapsed = getNow().getTime() - startTime;
  const timeoutId = setTimeout(kill, Math.max(0, timeout - elapsed));
  promise.finally(() => {
    clearTimeout(timeoutId);
  });
}
function compilationModeToArg(compilationMode) {
  switch (compilationMode) {
    case "standard":
      return void 0;
    case "debug":
      return "--debug";
    case "optimize":
      return "--optimize";
  }
}
function outputPathToAbsoluteString(outputPath) {
  switch (outputPath.tag) {
    case "OutputPath":
      return outputPath.writeToTemporaryDir ? outputPath.temporaryOutputPath.absolutePath : outputPath.theOutputPath.absolutePath;
    case "NullOutputPath":
      return "/dev/null";
  }
}
function maybeToArray(arg) {
  return arg === void 0 ? [] : [arg];
}
function parsePotentialElmMakeJson(command, stderr) {
  if (!stderr.endsWith("}")) {
    const errorIndex = stderr.lastIndexOf("elm: ");
    if (errorIndex !== -1) {
      return {
        tag: "ElmMakeCrashError",
        beforeError: stderr.startsWith("{") ? { tag: "Json", length: errorIndex } : { tag: "Text", text: stderr.slice(0, errorIndex) },
        error: stderr.slice(errorIndex),
        command
      };
    }
  }
  const match = elmStuffErrorMessagePrefixRegex.exec(stderr);
  const elmStuffError = match?.[0];
  const potentialJson = elmStuffError === void 0 ? stderr : stderr.slice(elmStuffError.length);
  return potentialJson.startsWith("{") ? parseActualElmMakeJson(command, potentialJson, elmStuffError?.trim()) : void 0;
}
function parseActualElmMakeJson(command, jsonString, extraError) {
  let json2;
  try {
    json2 = JSON.parse(jsonString.replace(/\t/g, "\\t"));
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmMakeJsonParseError",
      error,
      errorFilePath: tryWriteErrorFile({
        cwd: command.options.cwd,
        name: "ElmMakeJsonParseError",
        content: toPlainString(
          elmMakeJsonParseError(
            { tag: "NoLocation" },
            error,
            { tag: "ErrorFileBadContent", content: jsonString },
            command
          )
        ),
        hash: jsonString
      }),
      command
    };
  }
  try {
    return {
      tag: "ElmMakeError",
      error: ElmMakeError(json2),
      extraError
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmMakeJsonParseError",
      error,
      errorFilePath: tryWriteErrorFile({
        cwd: command.options.cwd,
        name: "ElmMakeJsonParseError",
        content: toPlainString(
          elmMakeJsonParseError(
            { tag: "NoLocation" },
            error,
            {
              tag: "ErrorFileBadContent",
              content: JSON.stringify(json2, null, 2)
            },
            command
          )
        ),
        hash: jsonString
      }),
      command
    };
  }
}
var elmJsonErrorMessageRegex = /^-- (.+) -+( elm\.json)?\r?\n([^]+)$/;
var elmStuffErrorMessagePrefixRegex = /^\+-+\r?\n(?:\|.*\r?\n)+\+-+\r?\n\r?\n/;
function install({
  elmJsonPath,
  env,
  getNow
}) {
  const dummy = absolutePathFromString(
    {
      tag: "AbsolutePath",
      absolutePath: env[__ELM_WATCH_TMP_DIR] ?? os2.tmpdir()
    },
    "ElmWatchDummy.elm"
  );
  try {
    fs6.writeFileSync(dummy.absolutePath, elmWatchDummy());
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      promise: Promise.resolve({
        tag: "CreatingDummyFailed",
        error
      }),
      kill: () => {
      }
    };
  }
  const command = {
    command: "elm",
    args: ["make", `--output=/dev/null`, dummy.absolutePath],
    options: {
      cwd: absoluteDirname(elmJsonPath.theElmJsonPath),
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stderr === "") {
          return {
            tag: "Success",
            elmInstallOutput: stdout.split(/\r?\n|\r/).filter((line) => line.startsWith("  ")).map((line) => ` ${line}`).join("\n").trimEnd()
          };
        }
        if (elmStuffErrorMessagePrefixRegex.test(stderr)) {
          return { tag: "ElmStuffError" };
        }
        const match = elmJsonErrorMessageRegex.exec(stderr);
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && match !== null) {
          const [, title, elmJson2, message] = match;
          if (elmJson2 !== void 0) {
            return { tag: "ElmJsonError" };
          }
          if (title !== void 0 && message !== void 0) {
            return {
              tag: "ElmInstallError",
              title,
              message
            };
          }
        }
        return {
          tag: "UnexpectedElmInstallOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: ({ force }) => {
      if (force) {
        kill();
      } else {
        delayKill(promise, startTime, getNow, env, kill);
      }
    }
  };
}
function elmWatchDummy() {
  return `
module ElmWatchDummy exposing (dummy)


dummy : ()
dummy =
    ()
  `.trim();
}

// src/Compile.ts
function installDependencies(env, logger, getNow, project) {
  let currentKill = void 0;
  const loadingMessageDelay = silentlyReadIntEnvValue(
    env[__ELM_WATCH_LOADING_MESSAGE_DELAY],
    100
  );
  const printStatusLineHelper = (emojiName, message, nonFancy) => printStatusLine({
    maxWidth: logger.config.columns,
    fancy: logger.config.fancy,
    isTTY: logger.config.isTTY,
    emojiName,
    string: logger.config.fancy ? message : `${message}: ${nonFancy}`
  });
  const continuation = async () => {
    const elmJsonsArray = Array.from(project.elmJsons);
    for (const [index, [elmJsonPath]] of elmJsonsArray.entries()) {
      const message = `Dependencies${index === 0 ? "" : ` (${index + 1}/${elmJsonsArray.length})`}`;
      const loadingMessage = printStatusLineHelper(
        "Busy",
        message,
        "in progress"
      );
      let didWriteLoadingMessage = false;
      const timeoutId = setTimeout(() => {
        logger.write(loadingMessage);
        didWriteLoadingMessage = true;
      }, loadingMessageDelay);
      const clearLoadingMessage = () => {
        if (didWriteLoadingMessage) {
          logger.moveCursor(0, -1);
          logger.clearLine(0);
        }
      };
      const onError = (error) => {
        clearLoadingMessage();
        logger.write(printStatusLineHelper("Error", message, "error"));
        logger.write("");
        logger.errorTemplate(error);
        return { tag: "Error" };
      };
      const { promise, kill } = install({ elmJsonPath, env, getNow });
      currentKill = kill;
      const result = await promise.finally(() => {
        currentKill = void 0;
      });
      clearTimeout(timeoutId);
      switch (result.tag) {
        case "ElmJsonError":
        case "ElmStuffError":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Skipped", message, "skipped"));
          }
          break;
        case "Killed":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Busy", message, "interrupted"));
          }
          return { tag: "Killed" };
        case "Success": {
          const gotOutput = result.elmInstallOutput !== "";
          if (didWriteLoadingMessage || gotOutput) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Success", message, "success"));
          }
          if (gotOutput) {
            logger.write(result.elmInstallOutput);
          }
          break;
        }
        case "CreatingDummyFailed":
          return onError(creatingDummyFailed(elmJsonPath, result.error));
        case "ElmNotFoundError":
          return onError(elmNotFoundError(elmJsonPath, result.command));
        case "OtherSpawnError":
          return onError(
            otherSpawnError(elmJsonPath, result.error, result.command)
          );
        case "ElmInstallError":
          return onError(
            elmInstallError(elmJsonPath, result.title, result.message)
          );
        case "UnexpectedElmInstallOutput":
          return onError(
            unexpectedElmInstallOutput(
              elmJsonPath,
              result.exitReason,
              result.stdout,
              result.stderr,
              result.command
            )
          );
      }
    }
    return { tag: "Success" };
  };
  return {
    promise: continuation(),
    kill: ({ force }) => {
      if (currentKill !== void 0) {
        currentKill({ force });
      }
    }
  };
}
function getOutputActions({
  project,
  runMode,
  includeInterrupted,
  prioritizedOutputs
}) {
  let index = 0;
  let numExecuting = 0;
  let numInterrupted = 0;
  let numErrors = 0;
  const elmMakeActions = [];
  const elmMakeTypecheckOnlyActions = [];
  const postprocessActions = [];
  const outputsWithoutAction = [];
  const busyElmJsons = new HashSet();
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    const typecheckOnly = [];
    for (const [outputPath, outputState] of outputs) {
      const output = {
        index,
        elmJsonPath,
        outputPath,
        outputState
      };
      index++;
      const priority = prioritizedOutputs === "AllEqualPriority" ? 0 : prioritizedOutputs.get(outputPath);
      const needsElm = (source) => {
        if (priority !== void 0) {
          elmMakeActions.push({
            tag: "NeedsElmMake",
            elmJsonPath,
            output,
            source,
            priority
          });
        } else {
          typecheckOnly.push({ output, source });
        }
      };
      switch (outputState.status.tag) {
        case "ElmMake":
        case "ElmMakeTypecheckOnly":
          numExecuting++;
          outputsWithoutAction.push(output);
          busyElmJsons.add(elmJsonPath);
          break;
        case "Postprocess":
          numExecuting++;
          outputsWithoutAction.push(output);
          break;
        case "QueuedForElmMake":
          needsElm("Queued");
          break;
        case "QueuedForPostprocess":
          postprocessActions.push({
            tag: "NeedsPostprocess",
            output,
            postprocessArray: outputState.status.postprocessArray,
            priority: priority ?? 0,
            code: outputState.status.code,
            elmCompiledTimestamp: outputState.status.elmCompiledTimestamp,
            recordFields: outputState.status.recordFields
          });
          break;
        case "Interrupted":
          numInterrupted++;
          if (includeInterrupted) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        case "Success":
        case "NotWrittenToDisk":
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        default: {
          const _ = outputState.status;
          numErrors++;
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        }
      }
    }
    if (isNonEmptyArray(typecheckOnly)) {
      elmMakeTypecheckOnlyActions.push({
        tag: "NeedsElmMakeTypecheckOnly",
        elmJsonPath,
        outputs: typecheckOnly
      });
    }
  }
  const prioritizedActions = prioritizeActions(
    runMode,
    elmMakeActions,
    elmMakeTypecheckOnlyActions,
    postprocessActions
  );
  const actions = [];
  const queueActions = [];
  const threadsLeft = Math.max(0, project.maxParallel - numExecuting);
  for (const action of prioritizedActions) {
    switch (action.tag) {
      case "NeedsElmMake":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          switch (action.source) {
            case "Dirty":
              queueActions.push({
                tag: "QueueForElmMake",
                output: action.output
              });
              break;
            case "Queued":
              outputsWithoutAction.push(action.output);
              break;
          }
        }
        break;
      case "NeedsElmMakeTypecheckOnly":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          for (const { output, source } of action.outputs) {
            switch (source) {
              case "Dirty":
                queueActions.push({
                  tag: "QueueForElmMake",
                  output
                });
                break;
              case "Queued":
                outputsWithoutAction.push(output);
                break;
            }
          }
        }
        break;
      case "NeedsPostprocess":
        if (actions.length < threadsLeft) {
          actions.push(action);
        } else {
          outputsWithoutAction.push(action.output);
        }
        break;
    }
  }
  return {
    total: index,
    numExecuting,
    numInterrupted,
    numErrors,
    actions: [...actions, ...queueActions],
    outputsWithoutAction
  };
}
function prioritizeActions(runMode, elmMakeActions, elmMakeTypecheckOnlyActions, postprocessActions) {
  switch (runMode) {
    case "make":
      return [
        ...elmMakeActions,
        ...elmMakeTypecheckOnlyActions,
        ...postprocessActions
      ];
    case "hot":
      return [
        ...sortByPriority(postprocessActions),
        ...sortByPriority(elmMakeActions),
        ...elmMakeTypecheckOnlyActions
      ];
  }
}
function sortByPriority(array4) {
  return array4.slice().sort((a, b) => b.priority - a.priority);
}
async function handleOutputAction({
  env,
  logger,
  getNow,
  runMode,
  elmWatchJsonPath,
  total,
  action,
  postprocess,
  postprocessWorkerPool
}) {
  switch (action.tag) {
    case "NeedsElmMake":
      return compileOneOutput({
        env,
        logger,
        getNow,
        runMode,
        total,
        ...action.output,
        postprocess
      });
    case "NeedsElmMakeTypecheckOnly":
      switch (runMode.tag) {
        case "make":
          throw new Error(
            `Got NeedsElmMakeTypecheckOnly in \`make\` mode!
${JSON.stringify(
              action,
              null,
              2
            )}`
          );
        case "hot":
          await typecheck({
            env,
            logger,
            getNow,
            runMode: runMode.tag,
            elmJsonPath: action.elmJsonPath,
            outputs: mapNonEmptyArray(action.outputs, ({ output }) => output),
            total,
            webSocketPort: runMode.webSocketPort
          });
          return { tag: "Nothing" };
      }
    case "NeedsPostprocess":
      return postprocessHelper({
        env,
        logger,
        runMode,
        elmWatchJsonPath,
        total,
        ...action.output,
        postprocessArray: action.postprocessArray,
        postprocessWorkerPool,
        code: action.code,
        elmCompiledTimestamp: action.elmCompiledTimestamp,
        recordFields: action.recordFields
      });
    case "QueueForElmMake":
      action.output.outputState.setStatus({ tag: "QueuedForElmMake" });
      updateStatusLine({
        logger,
        runMode: runMode.tag,
        total,
        ...action.output
      });
      return { tag: "Nothing" };
  }
}
async function compileOneOutput({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocess
}) {
  const startTimestamp = getNow().getTime();
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  outputState.dirty = false;
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: outputState.compilationMode,
    inputs: outputState.inputs,
    outputPath: {
      ...outputPath,
      writeToTemporaryDir: !(runMode.tag === "make" && postprocess.tag === "NoPostprocess")
    },
    env,
    getNow
  });
  const outputStatus = {
    tag: "ElmMake",
    compilationMode: outputState.compilationMode,
    elmDurationMs: -1,
    walkerDurationMs: -1,
    injectDurationMs: -1,
    kill
  };
  outputState.setStatus(outputStatus);
  updateStatusLineHelper();
  const [elmMakeResult, allRelatedElmFilePathsResult] = await Promise.all([
    promise.then((result) => {
      outputStatus.elmDurationMs = getNow().getTime() - startTimestamp;
      return result;
    }),
    Promise.resolve().then(() => {
      switch (runMode.tag) {
        case "make":
          return {
            tag: "Success",
            allRelatedElmFilePaths: outputState.allRelatedElmFilePaths
          };
        case "hot": {
          const result = getAllRelatedElmFilePaths(
            elmJsonPath,
            outputState.inputs
          );
          outputStatus.walkerDurationMs = getNow().getTime() - startTimestamp;
          return result;
        }
      }
    })
  ]);
  if (outputState.dirty || elmMakeResult.tag === "Killed") {
    outputState.setStatus({ tag: "Interrupted" });
    updateStatusLineHelper();
    return { tag: "Nothing" };
  }
  outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
    allRelatedElmFilePathsResult,
    outputState
  );
  const combinedResult = combineResults(
    elmMakeResult,
    allRelatedElmFilePathsResult
  );
  switch (combinedResult.tag) {
    case "elm make success + walker success":
      return onCompileSuccess(
        logger.config,
        getNow,
        updateStatusLineHelper,
        runMode,
        elmJsonPath,
        outputPath,
        outputState,
        outputStatus,
        postprocess
      );
    case "elm make success + walker failure":
      outputState.setStatus(combinedResult.walkerError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
    case "elm make failure + walker success":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
    case "elm make failure + walker failure":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
  }
}
function onCompileSuccess(loggerConfig, getNow, updateStatusLineHelper, runMode, elmJsonPath, outputPath, outputState, outputStatus, postprocess) {
  const elmCompiledTimestamp = getNow().getTime();
  switch (runMode.tag) {
    case "make":
      switch (postprocess.tag) {
        case "NoPostprocess": {
          let fileSize;
          try {
            fileSize = fs7.statSync(outputPath.theOutputPath.absolutePath).size;
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.theOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
        case "Postprocess": {
          let buffer;
          try {
            buffer = fs7.readFileSync(
              outputPath.temporaryOutputPath.absolutePath
            );
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.temporaryOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: buffer,
            elmCompiledTimestamp,
            recordFields: void 0
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    case "hot": {
      let code;
      try {
        code = fs7.readFileSync(
          outputPath.temporaryOutputPath.absolutePath,
          "utf8"
        );
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "ReadOutputError",
          error,
          triedPath: outputPath.temporaryOutputPath
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          elmJsonPath,
          outputPath,
          outputState
        };
      }
      const recordFields = getRecordFields(
        outputState.compilationMode,
        code
      );
      const newCode = inject(outputState.compilationMode, code);
      outputStatus.injectDurationMs = getNow().getTime() - elmCompiledTimestamp;
      switch (postprocess.tag) {
        case "NoPostprocess": {
          try {
            fs7.mkdirSync(
              absoluteDirname(outputPath.theOutputPath).absolutePath,
              { recursive: true }
            );
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              clientCode(
                outputPath,
                elmCompiledTimestamp,
                outputState.compilationMode,
                outputState.browserUiPosition,
                runMode.webSocketPort,
                loggerConfig.debug
              ) + newCode
            );
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "WriteOutputError",
              error,
              reasonForWriting: "InjectWebSocketClient"
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          const recordFieldsChanged2 = recordFieldsChanged(
            outputState.recordFields,
            recordFields
          );
          const fileSize = Buffer.byteLength(newCode);
          outputState.recordFields = recordFields;
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return recordFieldsChanged2 ? {
            tag: "FullyCompiledJSButRecordFieldsChanged",
            outputPath
          } : {
            tag: "FullyCompiledJS",
            outputPath,
            outputState,
            code: newCode,
            elmCompiledTimestamp
          };
        }
        case "Postprocess": {
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: newCode,
            elmCompiledTimestamp,
            recordFields
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    }
  }
}
function needsToWriteProxyFile(outputPath, versionedIdentifier2) {
  let handle;
  try {
    handle = fs7.openSync(outputPath.absolutePath, "r");
  } catch (unknownError) {
    const error = toError(unknownError);
    return error.code === "ENOENT" ? { tag: "Needed" } : { tag: "ReadError", error };
  }
  const buffer = Buffer.alloc(versionedIdentifier2.byteLength);
  try {
    fs7.readSync(handle, buffer);
  } catch (unknownError) {
    const error = toError(unknownError);
    return { tag: "ReadError", error };
  }
  return buffer.equals(versionedIdentifier2) ? { tag: "NotNeeded" } : { tag: "Needed" };
}
async function postprocessHelper({
  env,
  logger,
  runMode,
  elmWatchJsonPath,
  elmJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocessArray,
  postprocessWorkerPool,
  code,
  elmCompiledTimestamp,
  recordFields
}) {
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  const { promise, kill } = runPostprocess({
    env,
    elmWatchJsonPath,
    compilationMode: outputState.compilationMode,
    runMode: runMode.tag,
    outputPath,
    postprocessArray,
    postprocessWorkerPool,
    code
  });
  outputState.setStatus({ tag: "Postprocess", kill });
  updateStatusLineHelper();
  const postprocessResult = await promise;
  switch (postprocessResult.tag) {
    case "Killed":
      outputState.dirty = true;
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLineHelper();
      return { tag: "Nothing" };
    case "Success": {
      try {
        fs7.mkdirSync(absoluteDirname(outputPath.theOutputPath).absolutePath, {
          recursive: true
        });
        switch (runMode.tag) {
          case "make":
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              postprocessResult.code
            );
            break;
          case "hot": {
            const clientCode2 = clientCode(
              outputPath,
              elmCompiledTimestamp,
              outputState.compilationMode,
              outputState.browserUiPosition,
              runMode.webSocketPort,
              logger.config.debug
            );
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              typeof postprocessResult.code === "string" ? clientCode2 + postprocessResult.code : Buffer.concat([
                Buffer.from(clientCode2),
                postprocessResult.code
              ])
            );
            break;
          }
        }
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "WriteOutputError",
          error,
          reasonForWriting: "Postprocess"
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          elmJsonPath,
          outputPath,
          outputState
        };
      }
      const recordFieldsChanged2 = recordFieldsChanged(
        outputState.recordFields,
        recordFields
      );
      outputState.recordFields = recordFields;
      outputState.setStatus({
        tag: "Success",
        elmFileSize: Buffer.byteLength(code),
        postprocessFileSize: Buffer.byteLength(postprocessResult.code),
        elmCompiledTimestamp
      });
      updateStatusLineHelper();
      return recordFieldsChanged2 ? {
        tag: "FullyCompiledJSButRecordFieldsChanged",
        outputPath
      } : {
        tag: "FullyCompiledJS",
        outputPath,
        outputState,
        code: postprocessResult.code,
        elmCompiledTimestamp
      };
    }
    default:
      outputState.setStatus(postprocessResult);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
  }
}
async function typecheck({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputs,
  total,
  webSocketPort
}) {
  const startTimestamp = getNow().getTime();
  const outputsWithStatus = [];
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: "standard",
    inputs: nonEmptyArrayUniqueBy(
      (inputPath) => inputPath.realpath.absolutePath,
      flattenNonEmptyArray(
        mapNonEmptyArray(outputs, ({ outputState }) => outputState.inputs)
      )
    ),
    outputPath: { tag: "NullOutputPath" },
    env,
    getNow
  });
  for (const output of outputs) {
    const outputStatus = {
      tag: "ElmMakeTypecheckOnly",
      elmDurationMs: -1,
      walkerDurationMs: -1,
      kill
    };
    outputsWithStatus.push({ ...output, outputStatus });
    output.outputState.dirty = false;
    output.outputState.setStatus(outputStatus);
    updateStatusLine({
      logger,
      runMode,
      outputPath: output.outputPath,
      outputState: output.outputState,
      index: output.index,
      total
    });
  }
  const [elmMakeResult, allRelatedElmFilePathsResults] = await Promise.all([
    promise.then((result) => {
      const durationMs = getNow().getTime() - startTimestamp;
      for (const output of outputsWithStatus) {
        output.outputStatus.elmDurationMs = durationMs;
      }
      return result;
    }),
    Promise.resolve().then(
      () => outputsWithStatus.map(
        (output) => {
          const thisStartTimestamp = getNow().getTime();
          const allRelatedElmFilePathsResult = getAllRelatedElmFilePaths(
            elmJsonPath,
            output.outputState.inputs
          );
          output.outputStatus.walkerDurationMs = getNow().getTime() - thisStartTimestamp;
          return {
            ...output,
            allRelatedElmFilePathsResult
          };
        }
      )
    )
  ]);
  for (const {
    index,
    outputPath,
    outputState,
    allRelatedElmFilePathsResult
  } of allRelatedElmFilePathsResults) {
    if (outputState.dirty || elmMakeResult.tag === "Killed") {
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLine({
        logger,
        runMode,
        outputPath,
        outputState,
        index,
        total
      });
      continue;
    }
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      allRelatedElmFilePathsResult,
      outputState
    );
    const combinedResult = combineResults(
      onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult),
      allRelatedElmFilePathsResult
    );
    const proxyFileResult = needsToWriteProxyFile(
      outputPath.theOutputPath,
      Buffer.from(
        versionedIdentifier(outputPath.targetName, webSocketPort)
      )
    );
    switch (proxyFileResult.tag) {
      case "Needed":
        try {
          fs7.mkdirSync(absoluteDirname(outputPath.theOutputPath).absolutePath, {
            recursive: true
          });
          fs7.writeFileSync(
            outputPath.theOutputPath.absolutePath,
            proxyFile(
              outputPath,
              getNow().getTime(),
              outputState.browserUiPosition,
              webSocketPort,
              logger.config.debug
            )
          );
          outputState.setStatus({ tag: "NotWrittenToDisk" });
        } catch (unknownError) {
          const error = toError(unknownError);
          outputState.setStatus({ tag: "WriteProxyOutputError", error });
        }
        break;
      case "NotNeeded":
        outputState.setStatus({ tag: "NotWrittenToDisk" });
        break;
      case "ReadError":
        outputState.setStatus({
          tag: "NeedsToWriteProxyFileReadError",
          error: proxyFileResult.error,
          triedPath: outputPath.theOutputPath
        });
        break;
    }
    switch (combinedResult.tag) {
      case "elm make success + walker success":
        break;
      case "elm make success + walker failure":
        outputState.setStatus(combinedResult.walkerError);
        break;
      case "elm make failure + walker success":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
      case "elm make failure + walker failure":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
    }
    updateStatusLine({
      logger,
      runMode,
      outputPath,
      outputState,
      index,
      total
    });
  }
}
function onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult) {
  if (!(elmMakeResult.tag === "ElmMakeError" && elmMakeResult.error.tag === "CompileErrors")) {
    return elmMakeResult;
  }
  const errors = elmMakeResult.error.errors.filter(
    (error) => outputState.allRelatedElmFilePaths.has(error.path.absolutePath)
  );
  return isNonEmptyArray(errors) ? {
    tag: "ElmMakeError",
    error: { tag: "CompileErrors", errors },
    extraError: elmMakeResult.extraError
  } : { tag: "Success" };
}
function combineResults(elmMakeResult, allRelatedElmFilePathsResult) {
  switch (elmMakeResult.tag) {
    case "Success":
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make success + walker success",
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make success + walker failure",
            walkerError: allRelatedElmFilePathsResult
          };
      }
    default:
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make failure + walker success",
            elmMakeError: elmMakeResult,
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make failure + walker failure",
            elmMakeError: elmMakeResult,
            walkerError: allRelatedElmFilePathsResult
          };
      }
  }
}
function printSpaceForOutputs(logger, runMode, outputActions) {
  if (!logger.config.isTTY) {
    return;
  }
  if (isNonEmptyArray(outputActions.outputsWithoutAction)) {
    for (let index = 0; index < outputActions.total; index++) {
      const output = outputActions.outputsWithoutAction.find(
        (output2) => output2.index === index
      );
      if (output === void 0) {
        writeNewLines(logger, 1);
      } else {
        logger.write(
          statusLine(
            logger.config,
            runMode,
            output.outputPath,
            output.outputState
          )
        );
      }
    }
  } else {
    writeNewLines(logger, outputActions.total);
  }
}
function writeNewLines(logger, count) {
  if (count > 0) {
    logger.write("\n".repeat(count - 1));
  }
}
function updateStatusLine({
  logger,
  runMode,
  outputPath,
  outputState,
  index,
  total
}) {
  logger.moveCursor(0, -total + index);
  logger.clearLine(0);
  logger.write(statusLine(logger.config, runMode, outputPath, outputState));
  logger.moveCursor(0, total - index - 1);
}
var EMOJI = {
  QueuedForElmMake: {
    emoji: "\u26AA\uFE0F",
    description: "queued for elm make"
  },
  QueuedForPostprocess: {
    emoji: "\u{1F7E2}",
    description: "elm make done \u2013 queued for postprocess"
  },
  Busy: {
    emoji: "\u23F3",
    description: "elm make or postprocess"
  },
  Error: {
    emoji: "\u{1F6A8}",
    description: "error"
  },
  Skipped: {
    emoji: "\u26D4\uFE0F",
    description: "skipped"
  },
  Success: {
    emoji: "\u2705",
    description: "success"
  },
  Information: {
    emoji: "\u2139\uFE0F",
    description: "info"
  },
  Stats: {
    emoji: "\u{1F4CA}",
    description: "stats"
  }
};
function emojiWidthFix({
  emoji,
  column,
  isTTY
}) {
  return `${emoji}${isTTY ? cursorHorizontalAbsolute(column) : ""}`;
}
var GOOD_ENOUGH_STARTS_WITH_EMOJI_REGEX = /^(?:\p{Other_Symbol}[\u{1f3fb}-\u{1f3ff}]?\ufe0f?|[🇦-🇿]{2}) /u;
function targetNameEmojiTweak(loggerConfig, targetName) {
  const match = GOOD_ENOUGH_STARTS_WITH_EMOJI_REGEX.exec(targetName);
  if (match === null) {
    return { targetName, delta: 0 };
  }
  const content = match[0] ?? "";
  if (!loggerConfig.fancy) {
    return { targetName: targetName.slice(content.length), delta: 0 };
  }
  const start = emojiWidthFix({
    emoji: content.trim(),
    column: 6,
    isTTY: loggerConfig.isTTY
  });
  return {
    targetName: `${start} ${targetName.slice(content.length)}`,
    delta: -start.length + 2
  };
}
function printStatusLinesForElmJsonsErrors(logger, project) {
  for (const { outputPath } of project.elmJsonsErrors) {
    const { targetName, delta } = targetNameEmojiTweak(
      logger.config,
      outputPath.targetName
    );
    logger.write(
      printStatusLine({
        maxWidth: logger.config.columns - delta,
        fancy: logger.config.fancy,
        isTTY: logger.config.isTTY,
        emojiName: "Error",
        string: logger.config.fancy ? targetName : `${targetName}: error`
      })
    );
  }
}
function printErrors(logger, errors) {
  const errorStrings = Array.from(
    new Set(
      errors.map(
        (template2) => toTerminalString(
          template2,
          logger.config.columns,
          logger.config.noColor
        )
      )
    )
  );
  logger.write("");
  logger.write(join(errorStrings, "\n\n"));
  logger.write("");
  printNumErrors(logger, errorStrings.length);
}
function printNumErrors(logger, numErrors) {
  logger.write(
    printStatusLine({
      maxWidth: logger.config.columns,
      fancy: logger.config.fancy,
      isTTY: logger.config.isTTY,
      emojiName: "Error",
      string: `${bold(numErrors.toString())} error${numErrors === 1 ? "" : "s"} found`
    })
  );
}
function statusLine(loggerConfig, runMode, outputPath, outputState) {
  const { status } = outputState;
  const { targetName, delta } = targetNameEmojiTweak(
    loggerConfig,
    outputPath.targetName
  );
  const helper = (emojiName, string7) => printStatusLine({
    maxWidth: loggerConfig.columns - delta,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: string7
  });
  const withExtraDetailsAtEnd = (extra, emojiName, start) => {
    const strings = extra.flatMap((item) => item === void 0 ? [] : item);
    if (!isNonEmptyArray(strings)) {
      return helper(emojiName, start);
    }
    const startLength = (loggerConfig.fancy ? start.length + 3 : start.length) + delta;
    const end = join(strings, "   ");
    const max = Math.min(loggerConfig.columns, 100);
    const padding = loggerConfig.isTTY ? Math.max(3, max - end.length - startLength) : 3;
    return helper(
      emojiName,
      `${start}\0${" ".repeat(padding - 1)}${end}`
    ).replace(/\0(.*)$/, dim(" $1"));
  };
  switch (status.tag) {
    case "NotWrittenToDisk": {
      return withExtraDetailsAtEnd(
        [maybePrintDurations(loggerConfig, outputState.flushDurations())],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "Success": {
      return withExtraDetailsAtEnd(
        [
          maybePrintFileSize({
            runMode,
            compilationMode: outputState.compilationMode,
            elmFileSize: status.elmFileSize,
            postprocessFileSize: status.postprocessFileSize,
            fancy: loggerConfig.fancy
          }),
          maybePrintDurations(loggerConfig, outputState.flushDurations())
        ],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "ElmMake": {
      const arg = compilationModeToArg(status.compilationMode);
      const flags = arg === void 0 ? "" : ` ${arg}`;
      return helper("Busy", `${targetName}: elm make${flags}`);
    }
    case "ElmMakeTypecheckOnly":
      return helper("Busy", `${targetName}: elm make (typecheck only)`);
    case "Postprocess":
      return helper("Busy", `${targetName}: postprocess`);
    case "Interrupted":
      return helper("Busy", `${targetName}: interrupted`);
    case "QueuedForElmMake":
      return helper("QueuedForElmMake", `${targetName}: queued`);
    case "QueuedForPostprocess":
      return helper("QueuedForPostprocess", `${targetName}: elm make done`);
    case "ElmNotFoundError":
    case "CommandNotFoundError":
    case "OtherSpawnError":
    case "UnexpectedElmMakeOutput":
    case "PostprocessStdinWriteError":
    case "PostprocessNonZeroExit":
    case "ElmWatchNodeMissingScript":
    case "ElmWatchNodeImportError":
    case "ElmWatchNodeDefaultExportNotFunction":
    case "ElmWatchNodeRunError":
    case "ElmWatchNodeBadReturnValue":
    case "ElmMakeCrashError":
    case "ElmMakeJsonParseError":
    case "ElmMakeError":
    case "ElmJsonReadAsJsonError":
    case "ElmJsonDecodeError":
    case "ImportWalkerFileSystemError":
    case "NeedsToWriteProxyFileReadError":
    case "ReadOutputError":
    case "WriteOutputError":
    case "WriteProxyOutputError":
      return helper(
        "Error",
        loggerConfig.fancy ? targetName : `${targetName}: error`
      );
  }
}
function printStatusLine({
  maxWidth,
  fancy,
  isTTY,
  emojiName,
  string: string7
}) {
  const emojiString = emojiWidthFix({
    emoji: EMOJI[emojiName].emoji,
    column: 3,
    isTTY
  });
  const stringWithEmoji = fancy ? `${emojiString} ${string7}` : string7;
  if (!isTTY) {
    return stringWithEmoji;
  }
  const length = fancy ? string7.length + 3 : string7.length;
  return length <= maxWidth ? stringWithEmoji : fancy ? `${emojiString} ${string7.slice(0, maxWidth - 4)}\u2026` : `${string7.slice(0, maxWidth - 3)}...`;
}
function maybePrintFileSize({
  runMode,
  compilationMode,
  elmFileSize,
  postprocessFileSize,
  fancy
}) {
  switch (runMode) {
    case "make":
      switch (compilationMode) {
        case "debug":
        case "standard":
          return void 0;
        case "optimize":
          return postprocessFileSize === elmFileSize ? printFileSize(elmFileSize) : `${printFileSize(elmFileSize)} ${fancy ? "\u2192" : "->"} ${printFileSize(postprocessFileSize)} (${(postprocessFileSize / elmFileSize * 100).toFixed(1)} %)`;
      }
    case "hot":
      return void 0;
  }
}
function maybePrintDurations(loggerConfig, durations) {
  if (!isNonEmptyArray(durations)) {
    return void 0;
  }
  const newDurations = durations.some(
    (duration) => duration.tag === "QueuedForElmMake"
  ) ? durations : [{ tag: "QueuedForElmMake", durationMs: 0 }, ...durations];
  return join(
    mapNonEmptyArray(
      newDurations,
      (duration) => printDuration(
        loggerConfig.mockedTimings ? mockDuration(duration) : duration,
        loggerConfig.fancy
      )
    ),
    " | "
  );
}
function printDuration(duration, fancy) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return `${printDurationMs(duration.durationMs)} Q`;
    case "ElmMake":
    case "ElmMakeTypecheckOnly":
      return `${printDurationMs(duration.elmDurationMs)} ${duration.tag === "ElmMake" ? "E" : "T"}${duration.walkerDurationMs === -1 ? "" : ` ${fancy ? "\xA6" : "/"} ${printDurationMs(
        duration.walkerDurationMs
      )} W`}`;
    case "Inject":
      return `${printDurationMs(duration.durationMs)} I`;
    case "QueuedForPostprocess":
      return `${printDurationMs(duration.durationMs)} R`;
    case "Postprocess":
      return `${printDurationMs(duration.durationMs)} P`;
  }
}
function mockDuration(duration) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return {
        tag: "QueuedForElmMake",
        durationMs: 1
      };
    case "ElmMake":
      return {
        tag: "ElmMake",
        elmDurationMs: 1234,
        walkerDurationMs: duration.walkerDurationMs === -1 ? -1 : 55
      };
    case "ElmMakeTypecheckOnly":
      return {
        tag: "ElmMakeTypecheckOnly",
        elmDurationMs: 765,
        walkerDurationMs: 50
      };
    case "Inject":
      return {
        tag: "Inject",
        durationMs: 9
      };
    case "QueuedForPostprocess":
      return {
        tag: "QueuedForPostprocess",
        durationMs: 0
      };
    case "Postprocess":
      return {
        tag: "Postprocess",
        durationMs: 31234
      };
  }
}
function extractErrors(project) {
  return [
    ...project.elmJsonsErrors.map(renderElmJsonError),
    ...Array.from(project.elmJsons).flatMap(
      ([elmJsonPath, outputs]) => Array.from(outputs).flatMap(
        ([outputPath, { status }]) => renderOutputErrors(
          project.elmWatchJsonPath,
          elmJsonPath,
          outputPath,
          status,
          true
        )
      )
    )
  ];
}
function renderElmJsonError({
  outputPath,
  error
}) {
  switch (error.tag) {
    case "ElmJsonNotFound":
      return elmJsonNotFound(
        outputPath,
        error.elmJsonNotFound,
        error.foundElmJsonPaths
      );
    case "NonUniqueElmJsonPaths":
      return nonUniqueElmJsonPaths(
        outputPath,
        error.nonUniqueElmJsonPaths
      );
    case "InputsNotFound":
      return inputsNotFound(outputPath, error.inputsNotFound);
    case "InputsFailedToResolve":
      return inputsFailedToResolve(
        outputPath,
        error.inputsFailedToResolve
      );
    case "DuplicateInputs":
      return duplicateInputs(outputPath, error.duplicates);
  }
}
function renderOutputErrors(elmWatchJsonPath, elmJsonPath, outputPath, status, includeStuckInProgressState = false) {
  switch (status.tag) {
    case "NotWrittenToDisk":
      return [];
    case "ElmMake":
    case "ElmMakeTypecheckOnly":
    case "Postprocess":
    case "Interrupted":
    case "QueuedForElmMake":
      return includeStuckInProgressState ? [stuckInProgressState(outputPath, status.tag)] : [];
    case "QueuedForPostprocess":
      return [];
    case "Success":
      return [];
    case "ElmNotFoundError":
      return [elmNotFoundError(outputPath, status.command)];
    case "CommandNotFoundError":
      return [commandNotFoundError(outputPath, status.command)];
    case "OtherSpawnError":
      return [otherSpawnError(outputPath, status.error, status.command)];
    case "UnexpectedElmMakeOutput":
      return [
        unexpectedElmMakeOutput(
          outputPath,
          status.exitReason,
          status.stdout,
          status.stderr,
          status.command
        )
      ];
    case "PostprocessStdinWriteError":
      return [
        postprocessStdinWriteError(
          outputPath,
          status.error,
          status.command
        )
      ];
    case "PostprocessNonZeroExit":
      return [
        postprocessNonZeroExit(
          outputPath,
          status.exitReason,
          status.stdout,
          status.stderr,
          status.command
        )
      ];
    case "ElmWatchNodeMissingScript":
      return [elmWatchNodeMissingScript(elmWatchJsonPath)];
    case "ElmWatchNodeImportError":
      return [
        elmWatchNodeImportError(
          status.scriptPath,
          status.error,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeDefaultExportNotFunction":
      return [
        elmWatchNodeDefaultExportNotFunction(
          status.scriptPath,
          status.imported,
          status.typeofDefault,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeRunError":
      return [
        elmWatchNodeRunError(
          status.scriptPath,
          status.args,
          status.error,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeBadReturnValue":
      return [
        elmWatchNodeBadReturnValue(
          status.scriptPath,
          status.args,
          status.returnValue,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmMakeCrashError":
      return [
        elmMakeCrashError(
          outputPath,
          status.beforeError,
          status.error,
          status.command
        )
      ];
    case "ElmMakeJsonParseError":
      return [
        elmMakeJsonParseError(
          outputPath,
          status.error,
          status.errorFilePath,
          status.command
        )
      ];
    case "ElmMakeError":
      switch (status.error.tag) {
        case "GeneralError":
          return [
            elmMakeGeneralError(
              outputPath,
              elmJsonPath,
              status.error,
              status.extraError
            )
          ];
        case "CompileErrors":
          return status.error.errors.flatMap(
            (error) => error.problems.map(
              (problem) => elmMakeProblem(error.path, problem, status.extraError)
            )
          );
      }
    case "ElmJsonReadAsJsonError":
      return [readElmJsonAsJson(status.elmJsonPath, status.error)];
    case "ElmJsonDecodeError":
      return [decodeElmJson(status.elmJsonPath, status.error)];
    case "ImportWalkerFileSystemError":
      return [importWalkerFileSystemError(outputPath, status.error)];
    case "NeedsToWriteProxyFileReadError":
      return [
        needsToWriteProxyFileReadError(
          outputPath,
          status.error,
          status.triedPath
        )
      ];
    case "ReadOutputError":
      return [
        readOutputError(outputPath, status.error, status.triedPath)
      ];
    case "WriteOutputError":
      return [
        writeOutputError(
          outputPath,
          status.error,
          status.reasonForWriting
        )
      ];
    case "WriteProxyOutputError":
      return [writeProxyOutputError(outputPath, status.error)];
  }
}
function getAllRelatedElmFilePaths(elmJsonPath, inputs) {
  const parseResult = readAndParse(elmJsonPath);
  switch (parseResult.tag) {
    case "Parsed":
      return walkImports(
        getSourceDirectories(elmJsonPath, parseResult.elmJson),
        inputs
      );
    default:
      return parseResult;
  }
}
function allRelatedElmFilePathsWithFallback(walkerResult, outputState) {
  switch (walkerResult.tag) {
    case "Success":
      return walkerResult.allRelatedElmFilePaths;
    case "ImportWalkerFileSystemError":
      return walkerResult.relatedElmFilePathsUntilError;
    case "ElmJsonReadAsJsonError":
    case "ElmJsonDecodeError":
      return new Set(
        mapNonEmptyArray(
          outputState.inputs,
          (inputPath) => inputPath.realpath.absolutePath
        )
      );
  }
}
function ensureAllRelatedElmFilePaths(elmJsonPath, outputState) {
  if (outputState.allRelatedElmFilePaths.size === 0) {
    const result = getAllRelatedElmFilePaths(elmJsonPath, outputState.inputs);
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      result,
      outputState
    );
  }
}

// src/Help.ts
var elmWatchJson2 = bold("elm-watch.json");
function render(loggerConfig) {
  const symbolLegend = loggerConfig.fancy ? `
${bold("Symbol legend:")}

${join(
    Object.values(EMOJI).map(({ emoji, description }) => {
      const indent = "    ";
      return `${indent}${emojiWidthFix({
        emoji,
        column: indent.length + 3,
        isTTY: loggerConfig.isTTY
      })} ${description}`;
    }),
    "\n"
  )}
` : "";
  return `
${bold("elm-watch init")}
    Create a minimal ${elmWatchJson2} in the current directory.

${bold("elm-watch make [--debug|--optimize] [target names...]")}
    Compile Elm code into JS. Similar to ${bold("elm make")}.

${bold("elm-watch hot [target names...]")}
    Recompile whenever your Elm files change,
    and reload the compiled JS in the browser.
    You can switch to ${bold("--debug")} and ${bold("--optimize")}
    mode in the browser.

By default all targets in the closest ${elmWatchJson2} are built.
Pass ${bold("target names")} to only build some. Names are matched by substring!

${dim("---")}
${symbolLegend}
${bold("Durations legend:")}

    ${bold("Q")} queued for elm make
    ${bold("E")} elm make
    ${bold("T")} elm make (typecheck only)
    ${bold("W")} find all related Elm file paths
    ${bold("I")} inject hot reloading code
    ${bold("R")} queued for postprocess
    ${bold("P")} postprocess
    ${bold(loggerConfig.fancy ? "\xA6" : "/")} next is run in parallel

${dim("---")}

${bold("Environment variables:")}
    ${bold(NO_COLOR)}
        Disable colored output

    ${bold(ELM_WATCH_OPEN_EDITOR)}
        Open your editor when clicking error locations in the browser
        https://lydell.github.io/elm-watch/browser-ui/#clickable-error-locations

    ${bold(ELM_WATCH_EXIT_ON_STDIN_END)}
        Exit elm-watch when stdin ends

${bold("Documentation:")}
    https://lydell.github.io/elm-watch/

${bold("Version:")}
    1.1.2
`.trim();
}

// src/Init.ts
var fs8 = require("fs");
var elmWatchJson3 = bold("elm-watch.json");
function init(cwd, logger, args) {
  if (isNonEmptyArray(args)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${bold("elm-watch init")} takes no arguments.`
    );
    return 1;
  }
  const elmWatchJsonPath = {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: absolutePathFromString(cwd.path, "elm-watch.json")
  };
  if (fs8.existsSync(elmWatchJsonPath.theElmWatchJsonPath.absolutePath)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${elmWatchJson3} already exists in the current directory!`
    );
    return 1;
  }
  const example2 = example(cwd, elmWatchJsonPath, {
    elmFiles: [],
    output: void 0
  });
  try {
    fs8.writeFileSync(
      elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
      example2
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    logger.writeToStderrMakesALotOfSenseHere(
      `Failed to write ${elmWatchJson3}:

${error.message}`
    );
    return 1;
  }
  logger.write(
    `
Created a minimal ${elmWatchJson3} in the current directory to get you started.
Go check it out!

Documentation: https://lydell.github.io/elm-watch/elm-watch.json/
  `.trim()
  );
  return 0;
}

// src/CliArgs.ts
function parseArgs(runMode, args) {
  let debug = false;
  let optimize = false;
  const unknownFlags2 = [];
  const targetsSubstrings = [];
  for (const arg of args) {
    switch (arg.theArg) {
      case "--debug":
        debug = true;
        break;
      case "--optimize":
        optimize = true;
        break;
      default:
        if (arg.theArg.startsWith("-")) {
          unknownFlags2.push(arg);
        } else {
          targetsSubstrings.push(arg.theArg);
        }
    }
  }
  switch (runMode) {
    case "hot":
      if (debug || optimize) {
        return { tag: "DebugOptimizeForHot" };
      }
      break;
    case "make":
      if (debug && optimize) {
        return { tag: "DebugOptimizeClash" };
      }
      break;
  }
  if (isNonEmptyArray(unknownFlags2)) {
    return {
      tag: "UnknownFlags",
      unknownFlags: unknownFlags2
    };
  }
  return {
    tag: "Success",
    compilationMode: debug ? "debug" : optimize ? "optimize" : "standard",
    targetsSubstrings
  };
}

// src/ElmWatchStuffJson.ts
var fs9 = require("fs");
var Decode7 = require("tiny-decoders");

// src/Types.ts
var Decode6 = require("tiny-decoders");
var AbsolutePath = Decode6.fieldsAuto({
  tag: () => "AbsolutePath",
  absolutePath: Decode6.string
});
var CompilationMode = Decode6.stringUnion({
  debug: null,
  standard: null,
  optimize: null
});
var BrowserUiPosition = Decode6.stringUnion({
  TopLeft: null,
  TopRight: null,
  BottomLeft: null,
  BottomRight: null
});
function equalsInputPath(elmFile, inputPath) {
  return inputPath.theInputPath.absolutePath === elmFile.absolutePath || inputPath.realpath.absolutePath === elmFile.absolutePath;
}

// src/ElmWatchStuffJson.ts
var Target2 = Decode7.fieldsAuto({
  compilationMode: Decode7.optional(CompilationMode),
  browserUiPosition: Decode7.optional(BrowserUiPosition),
  openErrorOverlay: Decode7.optional(Decode7.boolean)
});
var ElmWatchStuffJson = Decode7.fieldsAuto({
  port: Port,
  targets: Decode7.record(Target2)
});
function readAndParse2(elmWatchStuffJsonPath) {
  let json2 = void 0;
  try {
    json2 = JSON.parse(
      fs9.readFileSync(
        elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
        "utf-8"
      )
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return error.code === "ENOENT" ? {
      tag: "NoElmWatchStuffJson",
      elmWatchStuffJsonPath
    } : {
      tag: "ElmWatchStuffJsonReadAsJsonError",
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmWatchStuffJsonPath,
      elmWatchStuffJson: ElmWatchStuffJson(json2)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmWatchStuffJsonDecodeError",
      error
    };
  }
}

// src/Hot.ts
var childProcess2 = require("child_process");
var chokidar = require("chokidar");
var fs10 = require("fs");
var path6 = require("path");
var Decode9 = require("tiny-decoders");
var import_url = require("url");

// client/WebSocketMessages.ts
var Decode8 = require("tiny-decoders");
var FocusedTabAcknowledged = Decode8.fieldsAuto({
  tag: () => "FocusedTabAcknowledged"
});
var OpenEditorError = Decode8.fieldsUnion("tag", {
  EnvNotSet: Decode8.fieldsAuto({
    tag: () => "EnvNotSet"
  }),
  CommandFailed: Decode8.fieldsAuto({
    tag: () => "CommandFailed",
    message: Decode8.string
  })
});
var OpenEditorFailed = Decode8.fieldsAuto({
  tag: () => "OpenEditorFailed",
  error: OpenEditorError
});
var ErrorLocation = Decode8.fieldsUnion("tag", {
  FileOnly: Decode8.fieldsAuto({
    tag: () => "FileOnly",
    file: AbsolutePath
  }),
  FileWithLineAndColumn: Decode8.fieldsAuto({
    tag: () => "FileWithLineAndColumn",
    file: AbsolutePath,
    line: Decode8.number,
    column: Decode8.number
  }),
  Target: Decode8.fieldsAuto({
    tag: () => "Target",
    targetName: Decode8.string
  })
});
var CompileError2 = Decode8.fieldsAuto({
  title: Decode8.string,
  location: Decode8.optional(ErrorLocation),
  htmlContent: Decode8.string
});
var StatusChanged = Decode8.fieldsAuto({
  tag: () => "StatusChanged",
  status: Decode8.fieldsUnion("tag", {
    AlreadyUpToDate: Decode8.fieldsAuto({
      tag: () => "AlreadyUpToDate",
      compilationMode: CompilationMode,
      browserUiPosition: BrowserUiPosition
    }),
    Busy: Decode8.fieldsAuto({
      tag: () => "Busy",
      compilationMode: CompilationMode,
      browserUiPosition: BrowserUiPosition
    }),
    CompileError: Decode8.fieldsAuto({
      tag: () => "CompileError",
      compilationMode: CompilationMode,
      browserUiPosition: BrowserUiPosition,
      openErrorOverlay: Decode8.boolean,
      errors: Decode8.array(CompileError2),
      foregroundColor: Decode8.string,
      backgroundColor: Decode8.string
    }),
    ElmJsonError: Decode8.fieldsAuto({
      tag: () => "ElmJsonError",
      error: Decode8.string
    }),
    ClientError: Decode8.fieldsAuto({
      tag: () => "ClientError",
      message: Decode8.string
    })
  })
});
var SuccessfullyCompiled = Decode8.fieldsAuto({
  tag: () => "SuccessfullyCompiled",
  code: Decode8.string,
  elmCompiledTimestamp: Decode8.number,
  compilationMode: CompilationMode,
  browserUiPosition: BrowserUiPosition
});
var SuccessfullyCompiledButRecordFieldsChanged = Decode8.fieldsAuto({
  tag: () => "SuccessfullyCompiledButRecordFieldsChanged"
});
var WebSocketToClientMessage = Decode8.fieldsUnion("tag", {
  FocusedTabAcknowledged,
  OpenEditorFailed,
  StatusChanged,
  SuccessfullyCompiled,
  SuccessfullyCompiledButRecordFieldsChanged
});
var WebSocketToServerMessage = Decode8.fieldsUnion("tag", {
  ChangedCompilationMode: Decode8.fieldsAuto({
    tag: () => "ChangedCompilationMode",
    compilationMode: CompilationMode
  }),
  ChangedBrowserUiPosition: Decode8.fieldsAuto({
    tag: () => "ChangedBrowserUiPosition",
    browserUiPosition: BrowserUiPosition
  }),
  ChangedOpenErrorOverlay: Decode8.fieldsAuto({
    tag: () => "ChangedOpenErrorOverlay",
    openErrorOverlay: Decode8.boolean
  }),
  FocusedTab: Decode8.fieldsAuto({
    tag: () => "FocusedTab"
  }),
  PressedOpenEditor: Decode8.fieldsAuto({
    tag: () => "PressedOpenEditor",
    file: AbsolutePath,
    line: Decode8.number,
    column: Decode8.number
  })
});
function encodeWebSocketToClientMessage(message) {
  switch (message.tag) {
    case "SuccessfullyCompiled": {
      const shortMessage = { ...message, code: "" };
      return `//${JSON.stringify(shortMessage)}
${message.code}`;
    }
    default:
      return JSON.stringify(message);
  }
}

// src/HashMap.ts
var util4 = require("util");
var _a2;
var HashMap = class {
  constructor(entries) {
    this.map = /* @__PURE__ */ new Map();
    this[_a2] = "HashMap";
    if (entries !== void 0 && entries !== null) {
      for (const [key, value] of entries) {
        this.map.set(hash2(key), value);
      }
    }
  }
  get size() {
    return this.map.size;
  }
  has(key) {
    return this.map.has(hash2(key));
  }
  get(key) {
    return this.map.get(hash2(key));
  }
  set(key, value) {
    this.map.set(hash2(key), value);
    return this;
  }
  delete(key) {
    return this.map.delete(hash2(key));
  }
  clear() {
    this.map.clear();
  }
  forEach(callback) {
    return callback;
  }
  *keys() {
    for (const key of this.map.keys()) {
      yield JSON.parse(key);
    }
  }
  values() {
    return this.map.values();
  }
  *entries() {
    for (const [key, value] of this.map.entries()) {
      yield [JSON.parse(key), value];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [(_a2 = Symbol.toStringTag, util4.inspect.custom)]() {
    return new Map(this);
  }
};
function hash2(value) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a < b ? -1 : 1)
    )
  );
}

// src/Project.ts
var os3 = require("os");
var OutputState = class {
  constructor(inputs, compilationMode, browserUiPosition, openErrorOverlay, getNow) {
    this.getNow = getNow;
    this._status = { tag: "NotWrittenToDisk" };
    this._durations = [];
    this._lastStartTimestamp = 0;
    this.openErrorOverlay = false;
    this.allRelatedElmFilePaths = /* @__PURE__ */ new Set();
    this.recordFields = void 0;
    this.dirty = true;
    this.inputs = inputs;
    this.compilationMode = compilationMode;
    this.browserUiPosition = browserUiPosition;
    this.openErrorOverlay = openErrorOverlay;
  }
  flushDurations() {
    const durations = this._durations.slice();
    this._durations.length = 0;
    return durations;
  }
  get status() {
    return this._status;
  }
  setStatus(status) {
    const lastStartTimestamp = this._lastStartTimestamp;
    this._lastStartTimestamp = this.getNow().getTime();
    switch (this._status.tag) {
      case "ElmMake":
        this._durations.push({
          tag: "ElmMake",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        if (this._status.injectDurationMs !== -1) {
          this._durations.push({
            tag: "Inject",
            durationMs: this._status.injectDurationMs
          });
        }
        break;
      case "ElmMakeTypecheckOnly":
        this._durations.push({
          tag: "ElmMakeTypecheckOnly",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        break;
      case "Postprocess":
      case "QueuedForElmMake":
      case "QueuedForPostprocess":
        this._durations.push({
          tag: this._status.tag,
          durationMs: this._lastStartTimestamp - lastStartTimestamp
        });
        break;
      default:
        this._durations.length = 0;
    }
    this._status = status;
  }
};
function initProject({
  env,
  getNow,
  compilationMode,
  elmWatchJsonPath,
  config,
  enabledTargetsSubstrings,
  elmWatchStuffDir,
  elmWatchStuffJsonPath,
  elmWatchStuffJson: elmWatchStuffJson2
}) {
  const disabledOutputs = new HashSet();
  const elmJsonsErrors = [];
  const elmJsons = new HashMap();
  const potentialOutputDuplicates = new HashMap();
  for (const [index, [targetName, target]] of Object.entries(
    config.targets
  ).entries()) {
    const outputPath = {
      tag: "OutputPath",
      theOutputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath),
        target.output
      ),
      temporaryOutputPath: absolutePathFromString(
        elmWatchStuffDir.theElmWatchStuffDir,
        `${index}.js`
      ),
      originalString: target.output,
      targetName
    };
    const previousOutput = potentialOutputDuplicates.get(
      outputPath.theOutputPath
    );
    if (previousOutput === void 0) {
      potentialOutputDuplicates.set(outputPath.theOutputPath, [
        outputPath.originalString
      ]);
    } else {
      previousOutput.push(outputPath.originalString);
    }
    if (enabledTargetsSubstrings.some(
      (substring) => targetName.includes(substring)
    )) {
      const resolveElmJsonResult = resolveElmJson(
        elmWatchJsonPath,
        target.inputs
      );
      const persisted = elmWatchStuffJson2?.targets[targetName];
      const {
        compilationMode: thisCompilationMode = compilationMode,
        browserUiPosition = "BottomLeft",
        openErrorOverlay = false
      } = persisted ?? {};
      switch (resolveElmJsonResult.tag) {
        case "Success": {
          const previous = elmJsons.get(resolveElmJsonResult.elmJsonPath) ?? new HashMap();
          previous.set(
            outputPath,
            new OutputState(
              resolveElmJsonResult.inputs,
              thisCompilationMode,
              browserUiPosition,
              openErrorOverlay,
              getNow
            )
          );
          elmJsons.set(resolveElmJsonResult.elmJsonPath, previous);
          break;
        }
        default:
          elmJsonsErrors.push({
            outputPath,
            compilationMode: thisCompilationMode,
            browserUiPosition,
            openErrorOverlay,
            error: resolveElmJsonResult
          });
          break;
      }
    } else {
      disabledOutputs.add(outputPath);
    }
  }
  const duplicateOutputs2 = Array.from(potentialOutputDuplicates).filter(([, outputPaths]) => outputPaths.length >= 2).map(([absolutePath, originalOutputPathStrings]) => ({
    originalOutputPathStrings,
    absolutePath
  }));
  if (isNonEmptyArray(duplicateOutputs2)) {
    return {
      tag: "DuplicateOutputs",
      duplicates: duplicateOutputs2
    };
  }
  const paths = [
    absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath),
    ...Array.from(elmJsons.keys()).flatMap(
      (elmJsonPath) => {
        const result = readAndParse(elmJsonPath);
        switch (result.tag) {
          case "Parsed":
            return [
              absoluteDirname(elmJsonPath.theElmJsonPath),
              ...getSourceDirectories(elmJsonPath, result.elmJson).map(
                (sourceDirectory) => sourceDirectory.theSourceDirectory
              )
            ];
          case "ElmJsonReadAsJsonError":
          case "ElmJsonDecodeError":
            return [absoluteDirname(elmJsonPath.theElmJsonPath)];
        }
      }
    )
  ];
  const watchRoot = longestCommonAncestorPath(paths);
  if (watchRoot === void 0) {
    return { tag: "NoCommonRoot", paths };
  }
  const maxParallel = silentlyReadIntEnvValue(
    env[__ELM_WATCH_MAX_PARALLEL],
    os3.cpus().length
  );
  const postprocess = config.postprocess === void 0 ? { tag: "NoPostprocess" } : { tag: "Postprocess", postprocessArray: config.postprocess };
  return {
    tag: "Project",
    project: {
      watchRoot,
      elmWatchJsonPath,
      elmWatchStuffJsonPath,
      disabledOutputs,
      elmJsonsErrors,
      elmJsons,
      maxParallel,
      postprocess
    }
  };
}
function resolveElmJson(elmWatchJsonPath, inputStrings) {
  const inputs = [];
  const inputsNotFound2 = [];
  const inputsFailedToResolve2 = [];
  const resolved = new HashMap();
  for (const inputString of inputStrings) {
    const uncheckedInputPath = {
      tag: "UncheckedInputPath",
      theUncheckedInputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath),
        inputString
      ),
      originalString: inputString
    };
    let realpath;
    try {
      realpath = absoluteRealpath(uncheckedInputPath.theUncheckedInputPath);
    } catch (unknownError) {
      const error = toError(unknownError);
      if (error.code === "ENOENT" || error.code === "ENOTDIR") {
        inputsNotFound2.push(uncheckedInputPath);
      } else {
        inputsFailedToResolve2.push({ inputPath: uncheckedInputPath, error });
      }
      continue;
    }
    const inputPath = {
      tag: "InputPath",
      theInputPath: uncheckedInputPath.theUncheckedInputPath,
      originalString: inputString,
      realpath
    };
    const previous = resolved.get(realpath);
    if (previous === void 0) {
      resolved.set(realpath, [inputPath]);
    } else {
      previous.push(inputPath);
    }
    inputs.push(inputPath);
  }
  if (isNonEmptyArray(inputsNotFound2)) {
    return {
      tag: "InputsNotFound",
      inputsNotFound: inputsNotFound2
    };
  }
  if (isNonEmptyArray(inputsFailedToResolve2)) {
    return {
      tag: "InputsFailedToResolve",
      inputsFailedToResolve: inputsFailedToResolve2
    };
  }
  const duplicateInputs2 = Array.from(resolved).filter(([, inputPaths]) => inputPaths.length >= 2).map(([resolvedPath, inputPaths]) => ({
    resolved: resolvedPath,
    inputs: inputPaths
  }));
  if (isNonEmptyArray(duplicateInputs2)) {
    return {
      tag: "DuplicateInputs",
      duplicates: duplicateInputs2
    };
  }
  const elmJsonNotFound2 = [];
  const elmJsonPaths = [];
  for (const inputPath of inputs) {
    const elmJsonPathRaw = findClosest(
      "elm.json",
      absoluteDirname(inputPath.theInputPath)
    );
    if (elmJsonPathRaw === void 0) {
      elmJsonNotFound2.push(inputPath);
    } else {
      elmJsonPaths.push({
        inputPath,
        elmJsonPath: { tag: "ElmJsonPath", theElmJsonPath: elmJsonPathRaw }
      });
    }
  }
  if (isNonEmptyArray(elmJsonNotFound2)) {
    return {
      tag: "ElmJsonNotFound",
      elmJsonNotFound: elmJsonNotFound2,
      foundElmJsonPaths: elmJsonPaths
    };
  }
  const elmJsonPathsSet = new HashSet(
    elmJsonPaths.map(({ elmJsonPath }) => elmJsonPath)
  );
  const uniqueElmJsonPath = getSetSingleton(elmJsonPathsSet);
  if (uniqueElmJsonPath === void 0) {
    return {
      tag: "NonUniqueElmJsonPaths",
      nonUniqueElmJsonPaths: elmJsonPaths
    };
  }
  return {
    tag: "Success",
    elmJsonPath: uniqueElmJsonPath,
    inputs
  };
}
function getFlatOutputs(project) {
  return Array.from(project.elmJsons.entries()).flatMap(
    ([elmJsonPath, outputs]) => Array.from(outputs, ([outputPath, outputState]) => ({
      elmJsonPath,
      outputPath,
      outputState
    }))
  );
}
function projectToDebug(project) {
  return {
    watchRoot: project.watchRoot.absolutePath,
    elmWatchJson: project.elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
    elmWatchStuffJson: project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
    maxParallel: project.maxParallel,
    postprocess: project.postprocess,
    enabledTargets: Array.from(project.elmJsons.entries()).flatMap(
      ([elmJsonPath, outputs]) => Array.from(outputs.entries(), ([outputPath, outputState]) => ({
        ...outputPathToDebug(outputPath),
        compilationMode: outputState.compilationMode,
        elmJson: elmJsonPath.theElmJsonPath.absolutePath,
        inputs: outputState.inputs.map(inputPathToDebug)
      }))
    ),
    disabledTargets: Array.from(project.disabledOutputs, outputPathToDebug),
    erroredTargets: project.elmJsonsErrors.map(
      ({ outputPath, compilationMode, error }) => ({
        error: error.tag,
        ...outputPathToDebug(outputPath),
        compilationMode
      })
    )
  };
}
function outputPathToDebug(outputPath) {
  return {
    targetName: outputPath.targetName,
    output: outputPath.theOutputPath.absolutePath,
    temporaryOutput: outputPath.temporaryOutputPath.absolutePath,
    originalString: outputPath.originalString
  };
}
function inputPathToDebug(inputPath) {
  return {
    input: inputPath.theInputPath.absolutePath,
    realpath: inputPath.realpath.absolutePath,
    originalString: inputPath.originalString
  };
}

// src/TeaProgram.ts
async function runTeaProgram(options) {
  return new Promise((resolve3, reject) => {
    const [initialModel, initialCmds] = options.init;
    let model = initialModel;
    const msgQueue = [];
    let killed = false;
    const dispatch = (dispatchedMsg) => {
      if (killed) {
        return;
      }
      const alreadyRunning = msgQueue.length > 0;
      msgQueue.push(dispatchedMsg);
      if (alreadyRunning) {
        return;
      }
      for (const msg of msgQueue) {
        const [newModel, cmds] = options.update(msg, model);
        model = newModel;
        runCmds(cmds);
      }
      msgQueue.length = 0;
    };
    const runCmds = (cmds) => {
      for (const cmd of cmds) {
        options.runCmd(
          cmd,
          mutable,
          dispatch,
          (result) => {
            cmds.length = 0;
            killed = true;
            resolve3(result);
          },
          (error) => {
            cmds.length = 0;
            killed = true;
            reject(error);
          }
        );
        if (killed) {
          break;
        }
      }
    };
    const mutable = options.initMutable(
      dispatch,
      (result) => {
        killed = true;
        resolve3(result);
      },
      (error) => {
        killed = true;
        reject(error);
      }
    );
    runCmds(initialCmds);
  });
}

// src/WebSocketServer.ts
var http = require("http");
var https = require("https");
var net = require("net");
var util5 = require("util");
var import_ws = require("ws");

// src/Certificate.ts
var CERTIFICATE = {
  key: `-----BEGIN PRIVATE KEY-----
MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQC012uZX87KEVJA
CjTlOoBX7mzfd/T9NxrBlOPhauhGrPyxZ2FmTjZSErtgS96UCUALHyaWIlfmGCtT
XcdZbLFCxNFNuK+kIpXktSO/ZLNnryUTpZFXparAUJpyfO0bjsfJr6jc21gRZFnN
C4pbB/YMDqtQr3o5AS5pqujncUOR0jBHb5EPqlAe4B8LcrB+Hza2wLwRpyGpouhK
Sg1AQDKNx8z0XwcCp1OCpgGniqwDr0QhGWZ4X+T2zivhHag2ZdbfuPYI3se9hl31
EX9X5OXNVKi+CVOu0CdsrWVMVm665A8oi/pVr+m8xZdivbEmQwNRbYLpEAc1UcE2
8yHu6PITcB9+i7bKtDMO4ULWFPO6xivXpQqXsA1og8D4yEDHrCzaD7iewPuxaAtT
bJONUMcoNobOD42K2gDs6ZYKzc2ci1GljsXfQ1iO9RSgxpmIwg7T+od5h6clZxwV
7L7YLvi06IXuroXiApXw4ZJa771Nt9xCcH42/AJ9Tka45B/nlF7rqcPPywsjR95t
cac77D8VJbZHj7oulvWdsks/elbs0Q6v0mkmxYu88lMaeXDR2DTaw1lyrF7H0zuY
MBgH/7JRqdQ59zh2iQ3GwAlS8eC4ACVOhMihWsBxNEsk2/WlgBByRDGDX0GTyEGH
yMjPtAi5qcsg7IolWwWqrz4Ik9JibQIDAQABAoICAFVlAA9N2ZU7tq4845t3E5Hy
KYEg4RQNSFovF6ijVgnBuBWBrtGjjy0UYVzolrMq5w4ZaJwunXku4o6cUv1cQRw5
WmisFGyaVFPKYZYIVFtarlRns4lC1q23oib77O89bgREKaYZAa48x9b2Yx/3U22A
I8+W/U0bzLHjHdXkezbJnTiuaz6NewYJaT97qfH0hV6pBmYDmPbE0ZH7A+TaK8Ud
mx+uG95Z6ypff5qA9hdLVQ2YM/YVukX9N2U3Hu6JCn1clvm7UXCimY2W9J4pnYZn
OsN6HgUHkAZWnuX8To98D9hiuRRrXCFi4MiksJlTvaZe4xlxEyZPc8Ch8N0jLOPL
Yp0RXbtBhE8sFLVPI0DTfXmJluGu91nUBPM5yl/cf4V+FPL7vGE98TDPVdq+ryih
5ebOATi5zW7/WPRBL1A1dtlKvwl06ZsMZ5S6zFHjr4QO2XyJ3VAKwx6lYl5ezPfb
2p9ccq5esjAAl3d0EggtLI2Y5vnMlpWUG2euupNanHhOSGMemtQLrmLTLQEL5WMW
F5nKjKMMutTAHVZlWyPPP/PAXmJBBRS80G7z1+qLOy3pYqGLML5d0H6wduMwyfof
uC16FvW/RmWlhxOiz/RLJi6a8jMhSqZPZ0GVOgsE+3mH4qndv6rI1GKKtuSjA1fo
i8uEfGp3ty5DdGWFSFMVAoIBAQDjbLXbZJE4p5wb3a3Ijb36xZHyruSWOa2DxWue
oPeyeXo/uQq26wuJWNHlaqXGxCH8tJXKKB3tikdBZQrFzok4wHbD2cF1m56aFYQ9
3LAlheZmmr3LvxqY0hLg+5viIHFywafGQxSt/7qBTizu9F1WQ/XVd4r5mgq9BIre
uunImEfq+7/8Xz3uNHk2kir6WYvhSB+bmge7u4qw4hfrKGvgZkUudTaBQOBByqlB
gk8N9MtFJ7HPbSlpXNfodK+ZLnOgnpfZs27BUEenFHcnTMcX6cJkJsOgeMUuLFoM
a3mJoz0NR3fOiaNIgTfhpe7H6jT75vmcSFVXO7OvnHnbBzj/AoIBAQDLkFOSLc4d
lZWYBehyUEPUgTTSJRNy09TY9uaBLB7E67ue6Ey8SWdaq1YFI9dYj7UGgRalNGX5
jprli/kOfl+LY3CCq471qMFJWMGaVyzOUmqTfXXuIvDr5N0+/gc1LvejcR1dGOWG
BFFnNgrIqYkgNrBn7qKmHJ+DS4/r6fmGp6LWXB1IZb4A3+0N3AtFYEvATycd6+ho
C64CtXHjOyrD6D6yIV1GSqHofBogW2Lw2cPll6rkwBrjnQQWY4ttFPRMivOA22Kj
5UL5x+O1cAF1gF2rcQjfFbgqxQ4xLgAxs34ZEyTAMlKFRHMEf71PrwSRiVt3qpry
j5JN0qL/61iTAoIBAQC5KVNPEqwhwmUZUv0gojahK6ZOPhKiNMeO13dtqYTB7KGZ
rCCLGQdFhekurgvWru01ABpMgykKs2CcX5XLwwJ6EEkh3/LgvBj/PrFyZHGNu10B
AM+ySR9weOkh//jEvMFhO0ZL52W43NKOYIW473/msmI+sJuX6NEBX+dovCmHRmSX
buy6nxifDl36DjurpKh8fOovF9NgB6s9pHbw4PIju2BsGMaNqbJsHoJ7cYrHxByT
a2Qbi7cBr7Oh8Q7e2rENftIHT03HWoNcBw+UEbCvSYUZYW45AtsXYsjV/9LuOteE
LkHfCLTGXV6P+zdT0N3ekgl8MnA5G8SKIA4eQ90lAoIBAQDKGc5+8O8UPDC7MBJp
e/r7/hOdF6ZJeLp3dhm/4TfjNk+eIvAcd5wfTsAmdkEU8gg+HueGuZEMxWJPyDpL
A3iEgQNxGDbk+th7o50DSM15QiYBrKvq89HRwfVO1xH84VaHdIQ8q70k4yCWofbu
5jL4QpO9fBULapuL1Pdct30/DSwEOovwFuMfJzLJcc/W3xYWJf+mG1MwCXiHw/EA
MvvwaKHmZG2gnfRFRwEBYvnGOc3eIkhOt9N6a6dlOwtwDz/ExqefJTC3m6R1LNmM
h1lLeViGH8E5Cu0/uUiv1wXmUlg9ON5h2xRGr4Cp1ND1TcPxYjfnhQA1FgmhLiEa
iGP1AoIBAFhDurkr/U0DsNGm3Cn2+GlarvoYPsXmLYJnv5yTanfII7XyBGtys2/5
sH4mEh4hx2wxHR0fDPfu4XZ4/vIMw5gg70gWRqJUeDiPvKPWWZizexNAgUx9ngc3
MCyA67cZZQ9lk10cNdujm8gjFi+I19iV43kA657IKQSQoptv+XKN4Bfuk6w0mjY1
XM1ZCpZVO/nhNmQYpgjYOMYEZuUXVwdOZx1LZXDu5kBQO2zstHkWBIKRjxPJ+gCa
vdD/AU3gLNUbUEF2rVx5YcKDQftjAMrZNtJ8GeuUK2Aoi1k5EYMo8fwkQ35UixNo
R54V/WirfICHJ9siZ4WsJk7VRFbvuhk=
-----END PRIVATE KEY-----

`,
  cert: `-----BEGIN CERTIFICATE-----
MIIE2jCCAsKgAwIBAgIJAI+JJie9DC+TMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV
BAMTCWxvY2FsaG9zdDAgFw0yMjEwMDgxMDA3MjlaGA8yMTIyMDkxNDEwMDcyOVow
FDESMBAGA1UEAxMJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
CgKCAgEAtNdrmV/OyhFSQAo05TqAV+5s33f0/TcawZTj4WroRqz8sWdhZk42UhK7
YEvelAlACx8mliJX5hgrU13HWWyxQsTRTbivpCKV5LUjv2SzZ68lE6WRV6WqwFCa
cnztG47Hya+o3NtYEWRZzQuKWwf2DA6rUK96OQEuaaro53FDkdIwR2+RD6pQHuAf
C3Kwfh82tsC8EachqaLoSkoNQEAyjcfM9F8HAqdTgqYBp4qsA69EIRlmeF/k9s4r
4R2oNmXW37j2CN7HvYZd9RF/V+TlzVSovglTrtAnbK1lTFZuuuQPKIv6Va/pvMWX
Yr2xJkMDUW2C6RAHNVHBNvMh7ujyE3Affou2yrQzDuFC1hTzusYr16UKl7ANaIPA
+MhAx6ws2g+4nsD7sWgLU2yTjVDHKDaGzg+NitoA7OmWCs3NnItRpY7F30NYjvUU
oMaZiMIO0/qHeYenJWccFey+2C74tOiF7q6F4gKV8OGSWu+9TbfcQnB+NvwCfU5G
uOQf55Re66nDz8sLI0febXGnO+w/FSW2R4+6Lpb1nbJLP3pW7NEOr9JpJsWLvPJT
Gnlw0dg02sNZcqxex9M7mDAYB/+yUanUOfc4dokNxsAJUvHguAAlToTIoVrAcTRL
JNv1pYAQckQxg19Bk8hBh8jIz7QIuanLIOyKJVsFqq8+CJPSYm0CAwEAAaMtMCsw
FAYDVR0RBA0wC4IJbG9jYWxob3N0MBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqG
SIb3DQEBCwUAA4ICAQAhTBoM/lPVF83iI+7bn+gzJyA9DD3sjgTFgM9cqyfWuemg
L/KMKCqaWO3FynGuig4mNArp589zR5+rVyZTa0mxevpxEvK2J+i5sIdzlcNKBJul
WB9UNvluuop/lrC+vugHcKXSUmZeVXhdyaoOEdjz3zzhC9n/ixaLXjl0HzikAt7O
gJgDdk/d4v0ybH67r/ZhT2n2UPWWO6T/H1jc/qNKJmvpHKhia76c4h5nNk+FpLwJ
getTEJPB2cV3kR/mpXkk66WHLi3QK83z6zRkhh4aarYQ1BU7D/W/RpQrfBKJyA5C
rUi4eQXjwdhr/Hs72tnLYQyXhOWL2vvA392eWKoy8WNsewNoOn7nYxAJv5D0zdJb
hernuFyr3CsZfvlPwUZvNI5oEEIu/Rhvhp7qna6Ujh8h95zjiW2khUpBRjno3oew
O6Hj04vqL7wrhO0gXsBfMkg4ECsTVqLGu3fFV2ZeUaDyKrOcNO8+gSAkbWy3LUAh
PoksgZB44l2C7I+B37uxjoN6AweaPv98+AkS/Mg792bFfY/ZF4xNMo8Y+HgSBS5C
xcqzmsQaDOjmf5q4mjxuaZIDxb3slwpR4vaAJqCcMWK8PXqHpTz2msImWhCNnXiy
GqfVp1GwG1kla18ts1d98QWyaWjbdveZp3HMWZzQY1xOzyUX4K4Ejhho5oNl4w==
-----END CERTIFICATE-----

`
};

// src/WebSocketServer.ts
var PolyHttpServer = class {
  constructor() {
    this.net = net.createServer();
    this.http = http.createServer();
    this.https = https.createServer(CERTIFICATE);
    this.net.on("connection", (socket) => {
      socket.once("data", (buffer) => {
        socket.pause();
        const server = buffer[0] === 22 ? this.https : this.http;
        socket.unshift(buffer);
        server.emit("connection", socket);
        server.on("close", () => {
          socket.destroy();
        });
        process.nextTick(() => socket.resume());
      });
    });
  }
  listen(port) {
    this.net.listen(port);
  }
  async close() {
    return new Promise((resolve3, reject) => {
      let numClosed = 0;
      const callback = (error) => {
        numClosed++;
        if (error !== void 0 && error.code !== "ERR_SERVER_NOT_RUNNING") {
          reject(error);
        } else if (numClosed === 3) {
          resolve3();
        }
      };
      this.net.close(callback);
      this.http.close(callback);
      this.https.close(callback);
    });
  }
  onRequest(listener) {
    this.http.on("request", listener(false));
    this.https.on("request", listener(true));
  }
  onUpgrade(listener) {
    this.http.on("upgrade", listener);
    this.https.on("upgrade", listener);
  }
  onError(listener) {
    this.net.on("error", listener);
    this.http.on("error", listener);
    this.https.on("error", listener);
  }
  onceListening(listener) {
    this.net.once("listening", () => {
      listener(this.net.address());
    });
  }
};
var WebSocketServer = class {
  constructor(portChoice) {
    this.polyHttpServer = new PolyHttpServer();
    this.webSocketServer = new import_ws.Server({ noServer: true });
    this.msgQueue = [];
    this.dispatchToQueue = (msg) => {
      this.msgQueue.push(msg);
    };
    this.dispatch = this.dispatchToQueue;
    this.webSocketServer.on("connection", (webSocket, request) => {
      webSocket[util5.inspect.custom] = (_depth, options) => options.stylize("WebSocket", "special");
      this.dispatch({
        tag: "WebSocketConnected",
        webSocket,
        urlString: request.url ?? "/"
      });
      webSocket.on("message", (data) => {
        this.dispatch({
          tag: "WebSocketMessageReceived",
          webSocket,
          data
        });
      });
      webSocket.on("close", () => {
        this.dispatch({ tag: "WebSocketClosed", webSocket });
      });
      webSocket.on("error", (error) => {
        this.dispatch({
          tag: "WebSocketServerError",
          error: { tag: "OtherError", error }
        });
      });
    });
    this.polyHttpServer.onError((error) => {
      this.dispatch({
        tag: "WebSocketServerError",
        error: error.code === "EADDRINUSE" ? { tag: "PortConflict", portChoice, error } : { tag: "OtherError", error }
      });
    });
    this.polyHttpServer.onRequest((isHttps) => (request, response) => {
      response.end(html(isHttps, request));
    });
    this.polyHttpServer.onUpgrade((request, socket, head) => {
      this.webSocketServer.handleUpgrade(request, socket, head, (webSocket) => {
        this.webSocketServer.emit("connection", webSocket, request);
      });
    });
    this.port = { tag: "Port", thePort: 0 };
    this.listening = new Promise((resolve3) => {
      this.polyHttpServer.onceListening((address) => {
        this.port.thePort = address.port;
        resolve3();
      });
    });
    this.polyHttpServer.listen(
      portChoice.tag === "NoPort" ? 0 : portChoice.port.thePort
    );
  }
  setDispatch(dispatch) {
    this.dispatch = dispatch;
    for (const msg of this.msgQueue) {
      dispatch(msg);
    }
  }
  unsetDispatch() {
    this.dispatch = this.dispatchToQueue;
  }
  async close() {
    this.unsetDispatch();
    this.webSocketServer.close();
    await this.polyHttpServer.close();
    for (const webSocket of this.webSocketServer.clients) {
      webSocket.close();
    }
  }
};
function html(isHttps, request) {
  const { host, referer } = request.headers;
  return `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>elm-watch</title>
    <style>
      html {
        font-family: system-ui, sans-serif;
      }
    </style>
  </head>
  <body>
    <p>\u2139\uFE0F This is the elm-watch WebSocket server.</p>
    ${request.url === "/accept" ? isHttps ? `<p>\u2705 Certificate accepted. You may now ${maybeLink(
    referer !== void 0 && new URL(referer).host !== host ? referer : void 0,
    "return to your page"
  )}.</p>` : `<p>Did you mean to go to the ${maybeLink(
    host !== void 0 ? `https://${host}${request.url}` : void 0,
    "HTTPS version of this page"
  )} to accept elm-watch's self-signed certificate?</p>` : `<p>There's nothing interesting to see here: <a href="https://lydell.github.io/elm-watch/getting-started/#your-responsibilities">elm-watch is not a file server</a>.</p>`}
  </body>
</html>
  `.trim();
}
function maybeLink(href, text2) {
  return href === void 0 ? text2 : `<a href="${href}">${text2}</a>`;
}

// src/Hot.ts
async function run(env, logger, getNow, restartReasons, postprocessWorkerPool, webSocketState, project, portChoice, hotKillManager) {
  const exitOnError = __ELM_WATCH_EXIT_ON_ERROR in env;
  const result = await runTeaProgram({
    initMutable: initMutable(
      env,
      logger,
      getNow,
      postprocessWorkerPool,
      webSocketState,
      project,
      portChoice,
      hotKillManager
    ),
    init: init2(getNow(), restartReasons, project.elmJsonsErrors),
    update: (msg, model) => {
      const [newModel, cmds] = update(
        logger.config,
        project,
        exitOnError,
        msg,
        model
      );
      const allCmds = [
        ...cmds,
        newModel.latestEvents.length > model.latestEvents.length ? {
          tag: "SleepBeforeNextAction",
          sleepMs: getNextActionSleepMs(newModel.latestEvents)
        } : { tag: "NoCmd" }
      ];
      logger.debug(msg.tag, msg, newModel, allCmds);
      return [newModel, allCmds];
    },
    runCmd: runCmd(env, logger, getNow, exitOnError)
  });
  delete hotKillManager.kill;
  return result;
}
async function watchElmWatchJsonOnce(getNow, elmWatchJsonPath) {
  return new Promise((resolve3, reject) => {
    const watcher = chokidar.watch(
      elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
      {
        ignoreInitial: true,
        disableGlobbing: true
      }
    );
    watcherOnAll(watcher, reject, (eventName, absolutePathString) => {
      const event = {
        tag: "WatcherEvent",
        date: getNow(),
        eventName,
        file: {
          tag: "AbsolutePath",
          absolutePath: absolutePathString
        }
      };
      watcher.close().then(() => {
        resolve3(event);
      }).catch(reject);
    });
  });
}
var initMutable = (env, logger, getNow, postprocessWorkerPool, webSocketState, project, portChoice, hotKillManager) => (dispatch, resolvePromise, rejectPromise) => {
  const workerLimitTimeoutMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS],
    1e4
  );
  const watcher = chokidar.watch(project.watchRoot.absolutePath, {
    ignoreInitial: true,
    ignored: /\/(elm-stuff|node_modules)\//,
    disableGlobbing: true
  });
  watcherOnAll(
    watcher,
    (error) => {
      closeAll(logger, mutable).then(() => {
        resolvePromise({
          tag: "ExitOnHandledFatalError",
          errorTemplate: watcherError(error)
        });
      }).catch(rejectPromise);
    },
    (eventName, absolutePathString) => {
      dispatch({
        tag: "GotWatcherEvent",
        date: getNow(),
        eventName,
        absolutePathString
      });
    }
  );
  const {
    webSocketServer = new WebSocketServer(portChoice),
    webSocketConnections = []
  } = webSocketState ?? {};
  const mutable = {
    watcher,
    postprocessWorkerPool,
    webSocketServer,
    webSocketConnections,
    lastWebSocketCloseTimestamp: void 0,
    workerLimitTimeoutMs,
    workerLimitTimeoutId: void 0,
    project,
    lastInfoMessage: void 0,
    watcherTimeoutId: void 0,
    elmWatchStuffJsonWriteError: void 0,
    killInstallDependencies: void 0
  };
  webSocketServer.setDispatch((msg) => {
    onWebSocketServerMsg(
      getNow(),
      logger,
      mutable,
      dispatch,
      resolvePromise,
      rejectPromise,
      msg
    );
  });
  postprocessWorkerPool.setCalculateMax(
    () => mutable.lastWebSocketCloseTimestamp !== void 0 && getNow().getTime() >= mutable.lastWebSocketCloseTimestamp + workerLimitTimeoutMs ? Math.max(1, makePrioritizedOutputs(mutable.webSocketConnections).size) : Infinity
  );
  webSocketServer.listening.then(() => {
    writeElmWatchStuffJson(mutable);
  }).catch(rejectPromise);
  const kill = async () => {
    try {
      if (mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies({ force: true });
      }
      await Promise.all(
        getFlatOutputs(project).map(
          ({ outputState }) => "kill" in outputState.status ? outputState.status.kill({ force: true }) : Promise.resolve()
        )
      );
      await closeAll(logger, mutable);
    } catch (unknownError) {
      const error = toError(unknownError);
      rejectPromise(toError(error));
    }
    delete hotKillManager.kill;
  };
  hotKillManager.kill = async () => {
    dispatch({ tag: "ExitRequested", date: getNow() });
    await kill();
    resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
  };
  logger.setRawMode(() => {
    kill().then(() => {
      resolvePromise({
        tag: "ExitOnIdle",
        reason: "CtrlCPressedOrStdinEnd"
      });
    }).catch(rejectPromise);
  });
  return mutable;
};
function writeElmWatchStuffJson(mutable) {
  const json2 = {
    port: mutable.webSocketServer.port.thePort,
    targets: Object.fromEntries([
      ...mutable.project.elmJsonsErrors.map(
        (error) => [
          error.outputPath.targetName,
          {
            compilationMode: error.compilationMode,
            browserUiPosition: error.browserUiPosition,
            openErrorOverlay: error.openErrorOverlay
          }
        ]
      ),
      ...getFlatOutputs(mutable.project).map(
        ({ outputPath, outputState }) => [
          outputPath.targetName,
          {
            compilationMode: outputState.compilationMode,
            browserUiPosition: outputState.browserUiPosition,
            openErrorOverlay: outputState.openErrorOverlay
          }
        ]
      )
    ])
  };
  try {
    fs10.mkdirSync(
      absoluteDirname(
        mutable.project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath
      ).absolutePath,
      { recursive: true }
    );
    fs10.writeFileSync(
      mutable.project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
      `${JSON.stringify(json2, null, 4)}
`
    );
    mutable.elmWatchStuffJsonWriteError = void 0;
  } catch (unknownError) {
    const error = toError(unknownError);
    mutable.elmWatchStuffJsonWriteError = error;
  }
}
function watcherOnAll(watcher, onError, onSuccess) {
  watcher.on("all", (chokidarEventName, absolutePathString) => {
    switch (chokidarEventName) {
      case "add":
      case "addDir":
        onSuccess("added", absolutePathString);
        return;
      case "unlink":
      case "unlinkDir":
        onSuccess("removed", absolutePathString);
        return;
      case "change":
        onSuccess("changed", absolutePathString);
        return;
    }
  });
  watcher.on("error", onError);
}
var init2 = (now, restartReasons, elmJsonsErrors) => [
  {
    nextAction: { tag: "NoAction" },
    hotState: {
      tag: "Dependencies",
      start: now
    },
    latestEvents: restartReasons
  },
  [
    { tag: "ClearScreen" },
    { tag: "InstallDependencies" },
    ...elmJsonsErrors.map(
      (elmJsonError) => ({
        tag: "WebSocketSendToOutput",
        outputPath: elmJsonError.outputPath,
        message: {
          tag: "StatusChanged",
          status: {
            tag: "ElmJsonError",
            error: toPlainString(
              renderElmJsonError(elmJsonError)
            )
          }
        }
      })
    )
  ]
];
function update(loggerConfig, project, exitOnError, msg, model) {
  switch (msg.tag) {
    case "GotWatcherEvent": {
      const result = onWatcherEvent(
        msg.date,
        project,
        msg.eventName,
        msg.absolutePathString,
        model.nextAction
      );
      if (result === void 0) {
        return [model, []];
      }
      const [updatedNextAction, latestEvent, cmds] = result;
      return [
        {
          ...model,
          nextAction: updatedNextAction,
          latestEvents: [...model.latestEvents, latestEvent]
        },
        cmds
      ];
    }
    case "ExitRequested":
      if (model.hotState.tag !== "Idle") {
        return [
          model,
          [
            {
              tag: "Throw",
              error: new Error(
                `Got ExitRequested. Expected hotState to be Idle but it is: ${model.hotState.tag}`
              )
            }
          ]
        ];
      }
      switch (model.nextAction.tag) {
        case "Restart":
        case "Compile":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `Got ExitRequested. Expected nextAction to be NoAction but it is: ${model.nextAction.tag}`
                )
              }
            ]
          ];
        case "NoAction":
          return runNextAction(msg.date, project, model);
      }
    case "SleepBeforeNextActionDone": {
      const [newModel, cmds] = runNextAction(msg.date, project, model);
      return [
        {
          ...newModel,
          nextAction: { tag: "NoAction" }
        },
        cmds
      ];
    }
    case "CompilationPartDone": {
      const includeInterrupted = model.nextAction.tag !== "Compile";
      const outputActions = getOutputActions({
        project,
        runMode: "hot",
        includeInterrupted,
        prioritizedOutputs: msg.prioritizedOutputs
      });
      switch (model.hotState.tag) {
        case "Dependencies":
        case "Idle":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while compiling!`
                )
              }
            ]
          ];
        case "Compiling": {
          const duration = msg.date.getTime() - model.hotState.start.getTime();
          const cmd = handleOutputActionResultToCmd(
            project.elmWatchJsonPath,
            msg.handleOutputActionResult
          );
          if (isNonEmptyArray(outputActions.actions)) {
            return [
              model,
              [
                cmd,
                {
                  tag: "CompileAllOutputsAsNeeded",
                  mode: "ContinueCompilation",
                  includeInterrupted
                }
              ]
            ];
          }
          if (outputActions.numExecuting > 0 || outputActions.numInterrupted > 0) {
            return [model, [cmd]];
          }
          const errors = extractErrors(project);
          return [
            { ...model, hotState: { tag: "Idle" }, latestEvents: [] },
            [
              cmd,
              isNonEmptyArray(errors) ? { tag: "PrintCompileErrors", errors } : { tag: "NoCmd" },
              { tag: "HandleElmWatchStuffJsonWriteError" },
              {
                tag: "LogInfoMessageWithTimeline",
                message: compileFinishedMessage(loggerConfig, duration),
                events: model.latestEvents
              },
              isNonEmptyArray(errors) && exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }
            ]
          ];
        }
        case "Restarting":
          return outputActions.numExecuting === 0 ? [model, [{ tag: "Restart", restartReasons: model.latestEvents }]] : [model, []];
      }
    }
    case "InstallDependenciesDone":
      switch (model.hotState.tag) {
        case "Dependencies": {
          switch (msg.installResult.tag) {
            case "Error":
              return [
                { ...model, hotState: { tag: "Idle" } },
                [
                  exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }
                ]
              ];
            case "Killed":
              return [{ ...model, hotState: { tag: "Idle" } }, []];
            case "Success": {
              return [
                {
                  ...model,
                  hotState: {
                    tag: "Compiling",
                    start: model.hotState.start
                  }
                },
                [
                  {
                    tag: "CompileAllOutputsAsNeeded",
                    mode: "AfterInstallDependencies",
                    includeInterrupted: true
                  }
                ]
              ];
            }
          }
        }
        case "Restarting":
          return [
            model,
            [{ tag: "Restart", restartReasons: model.latestEvents }]
          ];
        case "Idle":
        case "Compiling":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while installing dependencies!`
                )
              }
            ]
          ];
      }
    case "WebSocketClosed":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WebSocketClosed",
              date: msg.date,
              outputPath: msg.outputPath
            }
          ]
        },
        []
      ];
    case "WebSocketConnected": {
      const result = msg.parseWebSocketConnectRequestUrlResult;
      switch (result.tag) {
        case "Success": {
          const [newModel, latestEvent, cmds] = onWebSocketConnected(
            msg.date,
            model,
            project.elmWatchJsonPath,
            result.elmJsonPath,
            result.outputPath,
            result.outputState,
            result.elmCompiledTimestamp
          );
          return [
            {
              ...newModel,
              latestEvents: [...newModel.latestEvents, latestEvent]
            },
            cmds
          ];
        }
        case "ElmJsonError": {
          const elmJsonError = result.error;
          const event = {
            tag: "WebSocketConnectedNeedingNoAction",
            date: msg.date,
            outputPath: elmJsonError.outputPath
          };
          return [
            {
              ...model,
              latestEvents: [...model.latestEvents, event]
            },
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath: elmJsonError.outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ElmJsonError",
                    error: toPlainString(
                      renderElmJsonError(elmJsonError)
                    )
                  }
                }
              }
            ]
          ];
        }
        default:
          return [
            {
              ...model,
              latestEvents: [
                ...model.latestEvents,
                {
                  tag: "WebSocketConnectedWithErrors",
                  date: msg.date
                }
              ]
            },
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketConnectRequestUrlErrorToString(result)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WebSocketMessageReceived": {
      const result = parseWebSocketToServerMessage(msg.data);
      switch (result.tag) {
        case "Success":
          return onWebSocketToServerMessage(
            project.elmWatchJsonPath,
            model,
            msg.date,
            msg.output,
            msg.webSocket,
            result.message
          );
        case "DecodeError":
          return [
            model,
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketDecodeError(result.error)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WorkerLimitTimeoutPassed":
      return [model, [{ tag: "LimitWorkers" }]];
    case "WorkersLimited":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WorkersLimitedAfterWebSocketClosed",
              date: msg.date,
              numTerminatedWorkers: msg.numTerminatedWorkers
            }
          ]
        },
        []
      ];
  }
}
function onWatcherEvent(now, project, eventName, absolutePathString, nextAction) {
  if (absolutePathString.endsWith(".elm")) {
    return onElmFileWatcherEvent(
      project,
      makeWatcherEvent(eventName, absolutePathString, now),
      nextAction
    );
  }
  const basename2 = path6.basename(absolutePathString);
  switch (basename2) {
    case "elm-watch.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        case "changed":
        case "removed":
          if (absolutePathString === project.elmWatchJsonPath.theElmWatchJsonPath.absolutePath) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePathString, now),
              project
            );
          }
          return void 0;
      }
    case "elm.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        case "changed":
        case "removed":
          if (Array.from(project.elmJsons).some(
            ([elmJsonPath]) => absolutePathString === elmJsonPath.theElmJsonPath.absolutePath
          ) || isElmJsonFileRelatedToElmJsonsErrors(
            absolutePathString,
            project.elmJsonsErrors
          )) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePathString, now),
              project
            );
          }
          return void 0;
      }
    case "elm-stuff":
      switch (eventName) {
        case "removed":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        default:
          return void 0;
      }
    default:
      switch (project.postprocess.tag) {
        case "Postprocess": {
          const [commandName, scriptPathString] = project.postprocess.postprocessArray;
          if (commandName === ELM_WATCH_NODE && scriptPathString !== void 0) {
            const scriptPath = absolutePathFromString(
              absoluteDirname(project.elmWatchJsonPath.theElmWatchJsonPath),
              scriptPathString
            );
            if (absolutePathString === scriptPath.absolutePath) {
              return [
                compileNextAction(nextAction),
                {
                  ...makeWatcherEvent(eventName, absolutePathString, now),
                  affectsAnyTarget: true
                },
                [
                  {
                    tag: "MarkAsDirty",
                    outputs: getFlatOutputs(project),
                    killInstallDependencies: false
                  },
                  { tag: "RestartWorkers" }
                ]
              ];
            }
          }
          return void 0;
        }
        case "NoPostprocess":
          return void 0;
      }
  }
}
function onElmFileWatcherEvent(project, event, nextAction) {
  const elmFile = event.file;
  if (isElmFileRelatedToElmJsonsErrors(elmFile, project.elmJsonsErrors)) {
    return makeRestartNextAction(event, project);
  }
  const dirtyOutputs = [];
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    for (const [outputPath, outputState] of outputs) {
      if (event.eventName === "removed") {
        for (const inputPath of outputState.inputs) {
          if (equalsInputPath(elmFile, inputPath)) {
            return makeRestartNextAction(event, project);
          }
        }
      }
      ensureAllRelatedElmFilePaths(elmJsonPath, outputState);
      if (outputState.allRelatedElmFilePaths.has(elmFile.absolutePath)) {
        dirtyOutputs.push({ outputPath, outputState });
      }
    }
  }
  return isNonEmptyArray(dirtyOutputs) ? [
    compileNextAction(nextAction),
    { ...event, affectsAnyTarget: true },
    [
      {
        tag: "MarkAsDirty",
        outputs: dirtyOutputs,
        killInstallDependencies: false
      }
    ]
  ] : [nextAction, { ...event, affectsAnyTarget: false }, []];
}
function runNextAction(start, project, model) {
  switch (model.nextAction.tag) {
    case "Restart":
      switch (model.hotState.tag) {
        case "Idle":
          return [
            { ...model, hotState: { tag: "Restarting" } },
            [
              { tag: "ClearScreen" },
              { tag: "Restart", restartReasons: model.latestEvents }
            ]
          ];
        case "Dependencies":
        case "Compiling": {
          return [{ ...model, hotState: { tag: "Restarting" } }, []];
        }
        case "Restarting":
          return [model, []];
      }
    case "Compile":
      switch (model.hotState.tag) {
        case "Idle": {
          return [
            {
              ...model,
              hotState: { tag: "Compiling", start }
            },
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "AfterIdle",
                includeInterrupted: true
              }
            ]
          ];
        }
        case "Compiling":
          return [
            model,
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "ContinueCompilation",
                includeInterrupted: true
              }
            ]
          ];
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
    case "NoAction":
      switch (model.hotState.tag) {
        case "Idle":
          return isNonEmptyArray(model.latestEvents) ? [
            { ...model, latestEvents: [] },
            [
              {
                tag: "LogInfoMessageWithTimeline",
                message: printEventsMessage(
                  model.latestEvents,
                  project.disabledOutputs
                ),
                events: model.latestEvents
              }
            ]
          ] : [model, []];
        case "Compiling":
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
  }
}
var runCmd = (env, logger, getNow, exitOnError) => (cmd, mutable, dispatch, resolvePromise, rejectPromise) => {
  switch (cmd.tag) {
    case "ChangeBrowserUiPosition":
      cmd.outputState.browserUiPosition = cmd.browserUiPosition;
      writeElmWatchStuffJson(mutable);
      return;
    case "ChangeCompilationMode":
      cmd.outputState.compilationMode = cmd.compilationMode;
      writeElmWatchStuffJson(mutable);
      return;
    case "ChangeOpenErrorOverlay":
      cmd.outputState.openErrorOverlay = cmd.openErrorOverlay;
      writeElmWatchStuffJson(mutable);
      return;
    case "ClearScreen":
      logger.clearScreen();
      mutable.lastInfoMessage = void 0;
      return;
    case "CompileAllOutputsAsNeeded": {
      const outputActions = getOutputActions({
        project: mutable.project,
        runMode: "hot",
        includeInterrupted: cmd.includeInterrupted,
        prioritizedOutputs: makePrioritizedOutputs(
          mutable.webSocketConnections
        )
      });
      switch (cmd.mode) {
        case "AfterInstallDependencies":
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "AfterIdle":
          logger.clearScreen();
          mutable.lastInfoMessage = void 0;
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "ContinueCompilation":
          break;
      }
      if (isNonEmptyArray(outputActions.actions)) {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: {
              tag: "hot",
              webSocketPort: mutable.webSocketServer.port
            },
            elmWatchJsonPath: mutable.project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: mutable.project.postprocess,
            postprocessWorkerPool: mutable.postprocessWorkerPool
          }).then((handleOutputActionResult) => {
            dispatch({
              tag: "CompilationPartDone",
              date: getNow(),
              prioritizedOutputs: makePrioritizedOutputs(
                mutable.webSocketConnections
              ),
              handleOutputActionResult
            });
          }).catch(rejectPromise);
        }
      } else if (outputActions.numExecuting === 0) {
        dispatch({
          tag: "CompilationPartDone",
          date: getNow(),
          prioritizedOutputs: makePrioritizedOutputs(
            mutable.webSocketConnections
          ),
          handleOutputActionResult: { tag: "Nothing" }
        });
      }
      return;
    }
    case "HandleElmWatchStuffJsonWriteError":
      if (mutable.elmWatchStuffJsonWriteError !== void 0) {
        writeElmWatchStuffJson(mutable);
        if (mutable.elmWatchStuffJsonWriteError !== void 0) {
          logger.write("");
          logger.errorTemplate(
            elmWatchStuffJsonWriteError(
              mutable.project.elmWatchStuffJsonPath,
              mutable.elmWatchStuffJsonWriteError
            )
          );
          if (exitOnError) {
            closeAll(logger, mutable).then(() => {
              resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
            }).catch(rejectPromise);
          }
        }
      }
      return;
    case "InstallDependencies": {
      mutable.webSocketServer.listening.then(() => {
        const { promise, kill } = installDependencies(
          env,
          logger,
          getNow,
          mutable.project
        );
        mutable.killInstallDependencies = ({ force }) => {
          kill({ force });
          mutable.killInstallDependencies = void 0;
        };
        return promise;
      }).finally(() => {
        mutable.killInstallDependencies = void 0;
      }).then((installResult) => {
        dispatch({
          tag: "InstallDependenciesDone",
          date: getNow(),
          installResult
        });
      }).catch(rejectPromise);
      return;
    }
    case "LimitWorkers":
      mutable.postprocessWorkerPool.limit().then((numTerminatedWorkers) => {
        if (numTerminatedWorkers > 0) {
          dispatch({
            tag: "WorkersLimited",
            date: getNow(),
            numTerminatedWorkers
          });
        }
      }).catch(rejectPromise);
      return;
    case "LogInfoMessageWithTimeline": {
      if (mutable.lastInfoMessage !== void 0) {
        logger.moveCursor(0, -mutable.lastInfoMessage.split("\n").length);
        logger.clearScreenDown();
      }
      const fullMessage = infoMessageWithTimeline({
        loggerConfig: logger.config,
        date: getNow(),
        mutable,
        message: cmd.message,
        events: filterLatestEvents(cmd.events),
        hasErrors: isNonEmptyArray(extractErrors(mutable.project))
      });
      logger.write(fullMessage);
      logger.clearScreenDown();
      mutable.lastInfoMessage = fullMessage;
      if (__ELM_WATCH_EXIT_ON_WORKER_LIMIT in env && cmd.events.some(
        (event) => event.tag === "WorkersLimitedAfterWebSocketClosed"
      )) {
        closeAll(logger, mutable).then(() => {
          resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
        }).catch(rejectPromise);
      }
      return;
    }
    case "MarkAsDirty":
      if (cmd.killInstallDependencies && mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies({ force: false });
      }
      for (const { outputPath, outputState } of cmd.outputs) {
        outputState.dirty = true;
        if ("kill" in outputState.status) {
          Promise.resolve(outputState.status.kill({ force: false })).catch(
            rejectPromise
          );
        }
        webSocketSendToOutput(
          outputPath,
          {
            tag: "StatusChanged",
            status: {
              tag: "Busy",
              compilationMode: outputState.compilationMode,
              browserUiPosition: outputState.browserUiPosition
            }
          },
          mutable.webSocketConnections
        );
      }
      return;
    case "NoCmd":
      return;
    case "OpenEditor": {
      const command = env[ELM_WATCH_OPEN_EDITOR];
      const cwd = absoluteDirname(
        mutable.project.elmWatchJsonPath.theElmWatchJsonPath
      );
      const timeout = silentlyReadIntEnvValue(
        env[__ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS],
        5e3
      );
      const extraEnv = {
        file: cmd.file.absolutePath,
        line: cmd.line.toString(),
        column: cmd.column.toString()
      };
      if (command === void 0) {
        webSocketSend(cmd.webSocket, {
          tag: "OpenEditorFailed",
          error: { tag: "EnvNotSet" }
        });
      } else {
        childProcess2.exec(
          command,
          {
            cwd: cwd.absolutePath,
            env: { ...env, ...extraEnv },
            encoding: "utf8",
            timeout
          },
          (error, stdout, stderr) => {
            if (error !== null) {
              webSocketSend(cmd.webSocket, {
                tag: "OpenEditorFailed",
                error: {
                  tag: "CommandFailed",
                  message: openEditorCommandFailed({
                    error,
                    command,
                    cwd,
                    timeout,
                    env: extraEnv,
                    stdout,
                    stderr
                  })
                }
              });
            }
          }
        );
      }
      return;
    }
    case "PrintCompileErrors":
      printErrors(logger, cmd.errors);
      return;
    case "Restart": {
      const elmWatchJsonChanged = cmd.restartReasons.some((event) => {
        switch (event.tag) {
          case "WatcherEvent":
            return path6.basename(event.file.absolutePath) === "elm-watch.json";
          default:
            return false;
        }
      });
      closeAll(logger, mutable, {
        killWebSocketServer: elmWatchJsonChanged,
        killPostprocessWorkerPool: elmWatchJsonChanged
      }).then(() => {
        resolvePromise({
          tag: "Restart",
          restartReasons: cmd.restartReasons,
          postprocessWorkerPool: mutable.postprocessWorkerPool,
          webSocketState: elmWatchJsonChanged ? void 0 : {
            webSocketServer: mutable.webSocketServer,
            webSocketConnections: mutable.webSocketConnections
          }
        });
      }).catch(rejectPromise);
      return;
    }
    case "RestartWorkers":
      mutable.postprocessWorkerPool.terminate().then(() => {
        mutable.postprocessWorkerPool.getOrCreateAvailableWorker();
      }).catch(rejectPromise);
      return;
    case "ExitOnIdle":
      closeAll(logger, mutable).then(() => {
        resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
      }).catch(rejectPromise);
      return;
    case "SleepBeforeNextAction":
      if (mutable.watcherTimeoutId !== void 0) {
        clearTimeout(mutable.watcherTimeoutId);
      }
      mutable.watcherTimeoutId = setTimeout(() => {
        mutable.watcherTimeoutId = void 0;
        dispatch({ tag: "SleepBeforeNextActionDone", date: getNow() });
      }, cmd.sleepMs);
      return;
    case "Throw":
      rejectPromise(cmd.error);
      return;
    case "WebSocketSend":
      webSocketSend(cmd.webSocket, cmd.message);
      return;
    case "WebSocketSendCompileErrorToOutput":
      getThemeFromTerminal(logger).then((theme) => {
        const message = {
          tag: "StatusChanged",
          status: {
            tag: "CompileError",
            compilationMode: cmd.compilationMode,
            browserUiPosition: cmd.browserUiPosition,
            openErrorOverlay: cmd.openErrorOverlay,
            errors: cmd.errors.map(
              (errorTemplate) => toHtml(errorTemplate, theme, logger.config.noColor)
            ),
            foregroundColor: theme.foreground,
            backgroundColor: theme.background
          }
        };
        webSocketSendToOutput(
          cmd.outputPath,
          message,
          mutable.webSocketConnections
        );
      }).catch(rejectPromise);
      return;
    case "WebSocketSendToOutput":
      webSocketSendToOutput(
        cmd.outputPath,
        cmd.message,
        mutable.webSocketConnections
      );
      return;
    case "WebSocketUpdatePriority":
      for (const webSocketConnection of mutable.webSocketConnections) {
        if (webSocketConnection.webSocket === cmd.webSocket) {
          webSocketConnection.priority = getNow().getTime();
        }
      }
      return;
  }
};
function onWebSocketServerMsg(now, logger, mutable, dispatch, resolvePromise, rejectPromise, msg) {
  switch (msg.tag) {
    case "WebSocketConnected": {
      const result = parseWebSocketConnectRequestUrl(
        mutable.project,
        msg.urlString
      );
      const webSocketConnection = {
        webSocket: msg.webSocket,
        outputPath: webSocketConnectRequestUrlResultToOutputPath(result),
        priority: now.getTime()
      };
      mutable.webSocketConnections.push(webSocketConnection);
      dispatch({
        tag: "WebSocketConnected",
        date: now,
        parseWebSocketConnectRequestUrlResult: result,
        webSocket: msg.webSocket
      });
      return;
    }
    case "WebSocketClosed": {
      const removedConnection = mutable.webSocketConnections.find(
        (connection) => connection.webSocket === msg.webSocket
      );
      mutable.webSocketConnections = mutable.webSocketConnections.filter(
        (connection) => connection.webSocket !== msg.webSocket
      );
      mutable.lastWebSocketCloseTimestamp = now.getTime();
      if (mutable.workerLimitTimeoutId !== void 0) {
        clearTimeout(mutable.workerLimitTimeoutId);
      }
      mutable.workerLimitTimeoutId = setTimeout(() => {
        mutable.workerLimitTimeoutId = void 0;
        dispatch({ tag: "WorkerLimitTimeoutPassed" });
      }, mutable.workerLimitTimeoutMs);
      dispatch({
        tag: "WebSocketClosed",
        date: now,
        outputPath: removedConnection === void 0 ? { tag: "OutputPathError" } : removedConnection.outputPath
      });
      return;
    }
    case "WebSocketMessageReceived": {
      const webSocketConnection = mutable.webSocketConnections.find(
        ({ webSocket }) => webSocket === msg.webSocket
      );
      if (webSocketConnection === void 0) {
        rejectPromise(
          new Error(
            `No web socket connection found for web socket message ${JSON.stringify(
              msg.tag
            )}`
          )
        );
        return;
      }
      const flatOutputs = getFlatOutputs(mutable.project);
      const output = flatOutputs.find(
        ({ outputPath }) => webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)
      );
      dispatch({
        tag: "WebSocketMessageReceived",
        date: now,
        output: output === void 0 ? { tag: "OutputPathError" } : { tag: "Output", ...output },
        webSocket: msg.webSocket,
        data: msg.data
      });
      return;
    }
    case "WebSocketServerError":
      switch (msg.error.tag) {
        case "PortConflict": {
          const { portChoice } = msg.error;
          closeAll(logger, mutable).then(() => {
            resolvePromise({
              tag: "ExitOnHandledFatalError",
              errorTemplate: portChoiceError(
                mutable.project,
                portChoice,
                msg.error.error
              )
            });
          }).catch(rejectPromise);
          return;
        }
        case "OtherError":
          rejectPromise(msg.error.error);
          return;
      }
  }
}
function portChoiceError(project, portChoice, error) {
  switch (portChoice.tag) {
    case "NoPort":
      return portConflictForNoPort(error);
    case "PersistedPort":
      return portConflictForPersistedPort(
        project.elmWatchStuffJsonPath,
        portChoice.port
      );
    case "PortFromConfig":
      return portConflictForPortFromConfig(
        project.elmWatchJsonPath,
        portChoice.port
      );
  }
}
function handleOutputActionResultToCmd(elmWatchJsonPath, handleOutputActionResult) {
  switch (handleOutputActionResult.tag) {
    case "CompileError":
      return {
        tag: "WebSocketSendCompileErrorToOutput",
        outputPath: handleOutputActionResult.outputPath,
        compilationMode: handleOutputActionResult.outputState.compilationMode,
        browserUiPosition: handleOutputActionResult.outputState.browserUiPosition,
        openErrorOverlay: handleOutputActionResult.outputState.openErrorOverlay,
        errors: renderOutputErrors(
          elmWatchJsonPath,
          handleOutputActionResult.elmJsonPath,
          handleOutputActionResult.outputPath,
          handleOutputActionResult.outputState.status
        )
      };
    case "FullyCompiledJS":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: {
          tag: "SuccessfullyCompiled",
          code: handleOutputActionResult.code.toString("utf8"),
          elmCompiledTimestamp: handleOutputActionResult.elmCompiledTimestamp,
          compilationMode: handleOutputActionResult.outputState.compilationMode,
          browserUiPosition: handleOutputActionResult.outputState.browserUiPosition
        }
      };
    case "FullyCompiledJSButRecordFieldsChanged":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: { tag: "SuccessfullyCompiledButRecordFieldsChanged" }
      };
    case "Nothing":
      return { tag: "NoCmd" };
  }
}
async function closeAll(logger, mutable, { killWebSocketServer = true, killPostprocessWorkerPool = true } = {}) {
  logger.reset();
  if (mutable.workerLimitTimeoutId !== void 0) {
    clearTimeout(mutable.workerLimitTimeoutId);
  }
  if (mutable.watcherTimeoutId !== void 0) {
    clearTimeout(mutable.watcherTimeoutId);
  }
  mutable.webSocketServer.unsetDispatch();
  await Promise.all([
    mutable.watcher.close(),
    killWebSocketServer ? mutable.webSocketServer.close() : void 0,
    killPostprocessWorkerPool ? mutable.postprocessWorkerPool.terminate() : void 0
  ]);
}
function makePrioritizedOutputs(webSocketConnections) {
  const map = new HashMap();
  for (const { outputPath, priority } of webSocketConnections) {
    if (outputPath.tag !== "OutputPathError") {
      const previous = map.get(outputPath) ?? 0;
      map.set(outputPath, Math.max(priority, previous));
    }
  }
  return map;
}
function makeWatcherEvent(eventName, absolutePathString, date) {
  return {
    tag: "WatcherEvent",
    date,
    eventName,
    file: {
      tag: "AbsolutePath",
      absolutePath: absolutePathString
    }
  };
}
function makeRestartNextAction(event, project) {
  return [
    { tag: "Restart" },
    { ...event, affectsAnyTarget: true },
    [
      {
        tag: "MarkAsDirty",
        outputs: getFlatOutputs(project),
        killInstallDependencies: true
      }
    ]
  ];
}
function isElmFileRelatedToElmJsonsErrors(elmFile, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
        return error.duplicates.some(
          ({ inputs, resolved }) => resolved.absolutePath === elmFile.absolutePath || inputs.some((inputPath) => equalsInputPath(elmFile, inputPath))
        );
      case "ElmJsonNotFound":
        return error.elmJsonNotFound.some(
          (inputPath) => equalsInputPath(elmFile, inputPath)
        ) || error.foundElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
      case "InputsFailedToResolve":
        return error.inputsFailedToResolve.some(
          ({ inputPath }) => inputPath.theUncheckedInputPath.absolutePath === elmFile.absolutePath
        );
      case "InputsNotFound":
        return error.inputsNotFound.some(
          (inputPath) => inputPath.theUncheckedInputPath.absolutePath === elmFile.absolutePath
        );
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
    }
  });
}
function isElmJsonFileRelatedToElmJsonsErrors(absoluteElmJsonFilePath, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
      case "InputsFailedToResolve":
      case "InputsNotFound":
        return false;
      case "ElmJsonNotFound":
        return error.foundElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath.theElmJsonPath.absolutePath === absoluteElmJsonFilePath
        );
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath.theElmJsonPath.absolutePath === absoluteElmJsonFilePath
        );
    }
  });
}
function webSocketConnectionIsForOutputPath(webSocketConnection, outputPath) {
  switch (webSocketConnection.outputPath.tag) {
    case "OutputPathError":
      return false;
    case "OutputPath":
      return webSocketConnection.outputPath.theOutputPath.absolutePath === outputPath.theOutputPath.absolutePath;
  }
}
var WebSocketConnectedParams = Decode9.fieldsAuto(
  {
    elmWatchVersion: Decode9.string,
    targetName: Decode9.string,
    elmCompiledTimestamp: Decode9.chain(Decode9.string, (string7) => {
      const number5 = Number(string7);
      if (Number.isFinite(number5)) {
        return number5;
      }
      throw new Decode9.DecoderError({
        message: "Expected a number",
        value: string7
      });
    })
  },
  { exact: "throw" }
);
var WEBSOCKET_URL_EXPECTED_START = "/elm-watch?";
function parseWebSocketConnectRequestUrl(project, urlString) {
  if (!urlString.startsWith(WEBSOCKET_URL_EXPECTED_START)) {
    return {
      tag: "BadUrl",
      expectedStart: WEBSOCKET_URL_EXPECTED_START,
      actualUrlString: urlString
    };
  }
  const params = new import_url.URLSearchParams(
    urlString.slice(WEBSOCKET_URL_EXPECTED_START.length)
  );
  let webSocketConnectedParams;
  try {
    webSocketConnectedParams = WebSocketConnectedParams(
      Object.fromEntries(params)
    );
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ParamsDecodeError",
      error,
      actualUrlString: urlString
    };
  }
  if (webSocketConnectedParams.elmWatchVersion !== "1.1.2") {
    return {
      tag: "WrongVersion",
      expectedVersion: "1.1.2",
      actualVersion: webSocketConnectedParams.elmWatchVersion
    };
  }
  const flatOutputs = getFlatOutputs(project);
  const { targetName } = webSocketConnectedParams;
  const matchElmJsonError = project.elmJsonsErrors.find(
    ({ outputPath }) => outputPath.targetName === targetName
  );
  const matchOutput = flatOutputs.find(
    ({ outputPath }) => outputPath.targetName === targetName
  );
  if (matchElmJsonError !== void 0) {
    return {
      tag: "ElmJsonError",
      error: matchElmJsonError
    };
  } else if (matchOutput !== void 0) {
    return {
      tag: "Success",
      elmJsonPath: matchOutput.elmJsonPath,
      outputPath: matchOutput.outputPath,
      outputState: matchOutput.outputState,
      elmCompiledTimestamp: webSocketConnectedParams.elmCompiledTimestamp
    };
  } else {
    const enabledOutputs = [
      ...project.elmJsonsErrors.map(({ outputPath }) => outputPath),
      ...flatOutputs.map(({ outputPath }) => outputPath)
    ];
    const disabledOutputs = Array.from(project.disabledOutputs);
    const disabledMatch = disabledOutputs.find(
      (outputPath) => outputPath.targetName === targetName
    );
    return disabledMatch === void 0 ? {
      tag: "TargetNotFound",
      targetName,
      enabledOutputs,
      disabledOutputs
    } : {
      tag: "TargetDisabled",
      targetName,
      enabledOutputs,
      disabledOutputs
    };
  }
}
function webSocketConnectRequestUrlResultToOutputPath(result) {
  switch (result.tag) {
    case "Success":
      return result.outputPath;
    case "ElmJsonError":
      return result.error.outputPath;
    default: {
      const _ = result;
      return { tag: "OutputPathError" };
    }
  }
}
function webSocketConnectRequestUrlErrorToString(error) {
  switch (error.tag) {
    case "BadUrl":
      return webSocketBadUrl(error.expectedStart, error.actualUrlString);
    case "ParamsDecodeError":
      return webSocketParamsDecodeError(
        error.error,
        error.actualUrlString
      );
    case "WrongVersion":
      return webSocketWrongVersion(
        error.expectedVersion,
        error.actualVersion
      );
    case "TargetNotFound":
      return webSocketTargetNotFound(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
    case "TargetDisabled":
      return webSocketTargetDisabled(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
  }
}
function parseWebSocketToServerMessage(data) {
  const stringData = typeof data === "string" ? data : Array.isArray(data) ? Buffer.concat(data).toString("utf8") : data instanceof ArrayBuffer ? new TextDecoder("utf8").decode(data) : data.toString("utf8");
  try {
    return {
      tag: "Success",
      message: WebSocketToServerMessage(JSON.parse(stringData))
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return { tag: "DecodeError", error };
  }
}
function onWebSocketConnected(date, model, elmWatchJsonPath, elmJsonPath, outputPath, outputState, elmCompiledTimestamp) {
  const event = {
    tag: "WebSocketConnectedNeedingCompilation",
    date,
    outputPath
  };
  const recompileNeeded = () => {
    const [newModel, cmds] = onWebSocketRecompileNeeded(
      model,
      outputPath,
      outputState
    );
    return [newModel, event, cmds];
  };
  switch (model.hotState.tag) {
    case "Restarting":
    case "Dependencies":
      return [model, event, []];
    case "Idle":
    case "Compiling":
      switch (outputState.status.tag) {
        case "Success":
          return outputState.status.elmCompiledTimestamp === elmCompiledTimestamp ? [
            model,
            {
              tag: "WebSocketConnectedNeedingNoAction",
              date,
              outputPath
            },
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "AlreadyUpToDate",
                    compilationMode: outputState.compilationMode,
                    browserUiPosition: outputState.browserUiPosition
                  }
                }
              }
            ]
          ] : recompileNeeded();
        case "NotWrittenToDisk":
        case "ElmMakeTypecheckOnly":
          return recompileNeeded();
        case "ElmMake":
        case "Postprocess":
        case "Interrupted":
        case "QueuedForElmMake":
        case "QueuedForPostprocess":
          switch (model.hotState.tag) {
            case "Idle":
              return recompileNeeded();
            case "Compiling":
              return [model, event, []];
          }
        default: {
          const _ = outputState.status;
          return [
            model,
            event,
            [
              {
                tag: "WebSocketSendCompileErrorToOutput",
                outputPath,
                compilationMode: outputState.compilationMode,
                browserUiPosition: outputState.browserUiPosition,
                openErrorOverlay: outputState.openErrorOverlay,
                errors: renderOutputErrors(
                  elmWatchJsonPath,
                  elmJsonPath,
                  outputPath,
                  outputState.status
                )
              }
            ]
          ];
        }
      }
  }
}
function onChangedCompilationModeOrBrowserUiPosition(model, outputPath, outputState) {
  switch (model.hotState.tag) {
    case "Restarting":
    case "Dependencies":
      return [model, []];
    case "Idle":
    case "Compiling":
      return onWebSocketRecompileNeeded(model, outputPath, outputState);
  }
}
function onWebSocketRecompileNeeded(model, outputPath, outputState) {
  switch (model.nextAction.tag) {
    case "Restart":
      return [model, []];
    case "Compile":
    case "NoAction":
      return [
        {
          ...model,
          nextAction: { tag: "Compile" }
        },
        [
          {
            tag: "MarkAsDirty",
            outputs: [{ outputPath, outputState }],
            killInstallDependencies: false
          }
        ]
      ];
  }
}
function compileNextAction(nextAction) {
  switch (nextAction.tag) {
    case "Restart":
    case "Compile":
      return nextAction;
    case "NoAction":
      return { tag: "Compile" };
  }
}
function onWebSocketToServerMessage(elmWatchJsonPath, model, date, output, webSocket, message) {
  switch (message.tag) {
    case "ChangedCompilationMode":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const [newModel, cmds] = onChangedCompilationModeOrBrowserUiPosition(
            model,
            output.outputPath,
            output.outputState
          );
          return [
            {
              ...newModel,
              latestEvents: [
                ...newModel.latestEvents,
                {
                  tag: "WebSocketChangedCompilationMode",
                  date,
                  outputPath: output.outputPath,
                  compilationMode: message.compilationMode
                }
              ]
            },
            [
              {
                tag: "ChangeCompilationMode",
                outputState: output.outputState,
                compilationMode: message.compilationMode
              },
              ...cmds
            ]
          ];
        }
      }
    case "ChangedBrowserUiPosition":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const [newModel, cmds] = onChangedCompilationModeOrBrowserUiPosition(
            model,
            output.outputPath,
            output.outputState
          );
          return [
            {
              ...newModel,
              latestEvents: [
                ...newModel.latestEvents,
                {
                  tag: "WebSocketChangedBrowserUiPosition",
                  date,
                  outputPath: output.outputPath,
                  browserUiPosition: message.browserUiPosition
                }
              ]
            },
            [
              {
                tag: "ChangeBrowserUiPosition",
                outputState: output.outputState,
                browserUiPosition: message.browserUiPosition
              },
              ...cmds
            ]
          ];
        }
      }
    case "ChangedOpenErrorOverlay":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const errors = renderOutputErrors(
            elmWatchJsonPath,
            output.elmJsonPath,
            output.outputPath,
            output.outputState.status
          );
          return [
            model,
            [
              {
                tag: "ChangeOpenErrorOverlay",
                outputState: output.outputState,
                openErrorOverlay: message.openErrorOverlay
              },
              isNonEmptyArray(errors) ? {
                tag: "WebSocketSendCompileErrorToOutput",
                outputPath: output.outputPath,
                compilationMode: output.outputState.compilationMode,
                browserUiPosition: output.outputState.browserUiPosition,
                openErrorOverlay: message.openErrorOverlay,
                errors
              } : { tag: "NoCmd" }
            ]
          ];
        }
      }
    case "FocusedTab":
      return [
        model,
        [
          { tag: "WebSocketUpdatePriority", webSocket },
          {
            tag: "WebSocketSend",
            webSocket,
            message: { tag: "FocusedTabAcknowledged" }
          }
        ]
      ];
    case "PressedOpenEditor":
      return [
        model,
        [
          {
            tag: "OpenEditor",
            file: message.file,
            line: message.line,
            column: message.column,
            webSocket
          }
        ]
      ];
  }
}
function webSocketSend(webSocket, message) {
  webSocket.send(encodeWebSocketToClientMessage(message));
}
function webSocketSendToOutput(outputPath, message, webSocketConnections) {
  for (const webSocketConnection of webSocketConnections) {
    if (webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)) {
      webSocketSend(webSocketConnection.webSocket, message);
    }
  }
}
function getNextActionSleepMs(events) {
  return Math.max(0, ...events.map(getLatestEventSleepMs));
}
function getLatestEventSleepMs(event) {
  switch (event.tag) {
    case "WatcherEvent":
      return 10;
    case "WebSocketClosed":
    case "WebSocketConnectedNeedingCompilation":
    case "WebSocketConnectedNeedingNoAction":
    case "WebSocketConnectedWithErrors":
    case "WorkersLimitedAfterWebSocketClosed":
      return 100;
    case "WebSocketChangedBrowserUiPosition":
    case "WebSocketChangedCompilationMode":
      return 10;
  }
}
function filterLatestEvents(events) {
  const filtered = events.filter(
    (event) => !(event.tag === "WatcherEvent" && !event.affectsAnyTarget)
  );
  return isNonEmptyArray(filtered) ? filtered : events;
}
function infoMessageWithTimeline({
  loggerConfig,
  date,
  mutable,
  message,
  events,
  hasErrors
}) {
  return join(
    [
      "",
      printStats(loggerConfig, mutable),
      "",
      printTimeline(loggerConfig, events),
      printMessageWithTimeAndEmoji({
        loggerConfig,
        emojiName: hasErrors ? "Error" : "Success",
        date,
        dateHighlight: bold,
        message
      })
    ].flatMap((part) => part === void 0 ? [] : part),
    "\n"
  );
}
function printMessageWithTimeAndEmoji({
  loggerConfig,
  emojiName,
  date,
  dateHighlight: highlightTime,
  message
}) {
  const newDate = loggerConfig.mockedTimings ? new Date("2022-02-05T13:10:05Z") : date;
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: `${highlightTime(formatTime(newDate))} ${message}`
  });
}
function printStats(loggerConfig, mutable) {
  const numWorkers = mutable.postprocessWorkerPool.getSize();
  return join(
    [
      numWorkers > 0 ? `${dim(`${ELM_WATCH_NODE} workers:`)} ${numWorkers}` : void 0,
      `${dim("web socket connections:")} ${mutable.webSocketConnections.length} ${dim(`(ws://0.0.0.0:${mutable.webSocketServer.port.thePort})`)}`
    ].flatMap(
      (part) => part === void 0 ? [] : printStatusLine({
        maxWidth: Infinity,
        fancy: loggerConfig.fancy,
        isTTY: loggerConfig.isTTY,
        emojiName: "Stats",
        string: part
      })
    ),
    "\n"
  );
}
function printTimeline(loggerConfig, events) {
  if (!isNonEmptyArray(events)) {
    return void 0;
  }
  const base = 2;
  if (events.length <= 2 * base + 1) {
    return dim(
      join(
        mapNonEmptyArray(events, (event) => printEvent(loggerConfig, event)),
        "\n"
      )
    );
  }
  const start = events.slice(0, base);
  const end = events.slice(-base);
  const numMoreEvents = events.length - 2 * base;
  return dim(
    join(
      [
        ...start.map((event) => printEvent(loggerConfig, event)),
        `${loggerConfig.fancy ? "   " : ""}(${numMoreEvents} more events)`,
        ...end.map((event) => printEvent(loggerConfig, event))
      ],
      "\n"
    )
  );
}
function printEvent(loggerConfig, event) {
  return printMessageWithTimeAndEmoji({
    loggerConfig,
    emojiName: "Information",
    date: event.date,
    dateHighlight: (string7) => string7,
    message: printEventMessage(event)
  });
}
function printEventMessage(event) {
  switch (event.tag) {
    case "WatcherEvent":
      return `${capitalize(event.eventName)} ${event.file.absolutePath}`;
    case "WebSocketClosed":
      return `Web socket disconnected for: ${event.outputPath.tag === "OutputPath" ? event.outputPath.targetName : "(no matching target)"}`;
    case "WebSocketConnectedNeedingCompilation":
      return `Web socket connected needing compilation of: ${event.outputPath.targetName}`;
    case "WebSocketConnectedNeedingNoAction":
      return `Web socket connected for: ${event.outputPath.targetName}`;
    case "WebSocketConnectedWithErrors":
      return `Web socket connected with errors (see the browser for details)`;
    case "WebSocketChangedBrowserUiPosition":
      return `Changed browser UI position to ${JSON.stringify(
        event.browserUiPosition
      )} of: ${event.outputPath.targetName}`;
    case "WebSocketChangedCompilationMode":
      return `Changed compilation mode to ${JSON.stringify(
        event.compilationMode
      )} of: ${event.outputPath.targetName}`;
    case "WorkersLimitedAfterWebSocketClosed":
      return `Terminated ${event.numTerminatedWorkers} superfluous ${event.numTerminatedWorkers === 1 ? "worker" : "workers"}`;
  }
}
function compileFinishedMessage(loggerConfig, duration) {
  return `Compilation finished in ${bold(
    printDurationMs(
      loggerConfig.mockedTimings ? 123 : duration
    ).trim()
  )}.`;
}
function printEventsMessage(events, disabledOutputs) {
  const what1 = events.length === 1 ? "file is" : "files are";
  const what2 = disabledOutputs.size > 0 ? "any of the enabled targets" : "any target";
  return events.every(
    (event) => event.tag === "WatcherEvent" && !event.affectsAnyTarget
  ) ? `FYI: The above Elm ${what1} not imported by ${what2}. Nothing to do!` : "Everything up to date.";
}

// src/Make.ts
async function run2(env, logger, getNow, project, postprocessWorkerPool) {
  const startTimestamp = getNow().getTime();
  const installResult = await installDependencies(
    env,
    logger,
    getNow,
    project
  ).promise;
  switch (installResult.tag) {
    case "Error":
    case "Killed":
      return { tag: "Error" };
    case "Success":
      break;
  }
  const initialOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  printStatusLinesForElmJsonsErrors(logger, project);
  if (isNonEmptyArray(initialOutputActions.actions) && !isNonEmptyArray(project.elmJsonsErrors)) {
    printSpaceForOutputs(logger, "make", initialOutputActions);
    await new Promise((resolve3, reject) => {
      const cycle = (outputActions) => {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: { tag: "make" },
            elmWatchJsonPath: project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: project.postprocess,
            postprocessWorkerPool
          }).then(() => {
            const nextOutputActions = getNextOutputActions(project);
            if (isNonEmptyArray(nextOutputActions.actions)) {
              cycle(nextOutputActions);
            } else if (nextOutputActions.numExecuting === 0) {
              resolve3();
            }
          }).catch(reject);
        }
      };
      cycle(initialOutputActions);
    });
  }
  const numWorkers = postprocessWorkerPool.getSize();
  await postprocessWorkerPool.terminate();
  const errors = extractErrors(project);
  const failed = isNonEmptyArray(errors);
  if (failed) {
    printErrors(logger, errors);
  }
  const duration = getNow().getTime() - startTimestamp;
  logger.write("");
  logger.write(
    compileFinishedMessage2({
      loggerConfig: logger.config,
      duration,
      numWorkers,
      hasErrors: failed
    })
  );
  return failed ? { tag: "Error" } : { tag: "Success" };
}
function getNextOutputActions(project) {
  const nextOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  return nextOutputActions.numErrors > 0 ? {
    ...nextOutputActions,
    actions: nextOutputActions.actions.filter(
      (action2) => action2.tag !== "NeedsPostprocess"
    )
  } : nextOutputActions;
}
function compileFinishedMessage2({
  loggerConfig,
  duration,
  numWorkers,
  hasErrors
}) {
  const workersString = numWorkers > 0 ? dim(
    ` (using ${numWorkers} ${ELM_WATCH_NODE} ${numWorkers === 1 ? "worker" : "workers"}).`
  ) : ".";
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName: hasErrors ? "Error" : "Success",
    string: `Compilation finished in ${bold(
      printDurationMs(
        loggerConfig.mockedTimings ? 123 : duration
      ).trim()
    )}${workersString}`
  });
}

// src/Run.ts
async function run3(cwd, env, logger, getNow, runMode, args, restartReasons, postprocessWorkerPool, webSocketState, hotKillManager) {
  const parseResult = findReadAndParse(cwd);
  switch (parseResult.tag) {
    case "ReadAsJsonError":
      logger.errorTemplate(
        readElmWatchJsonAsJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "DecodeError":
      logger.errorTemplate(
        decodeElmWatchJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "ElmWatchJsonNotFound":
      logger.errorTemplate(elmWatchJsonNotFound(cwd, args));
      return { tag: "Exit", exitCode: 1 };
    case "Parsed": {
      const parseArgsResult = parseArgs(runMode, args);
      switch (parseArgsResult.tag) {
        case "UnknownFlags":
          logger.errorTemplate(
            unknownFlags(
              cwd,
              parseResult.elmWatchJsonPath,
              runMode,
              args,
              parseArgsResult.unknownFlags
            )
          );
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeForHot":
          logger.errorTemplate(debugOptimizeForHot());
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeClash":
          logger.errorTemplate(debugOptimizeClash());
          return { tag: "Exit", exitCode: 1 };
        case "Success": {
          const { config } = parseResult;
          const knownTargets = Object.keys(
            config.targets
          );
          const unknownTargetsSubstrings2 = parseArgsResult.targetsSubstrings.filter(
            (substring) => !knownTargets.some(
              (targetName) => targetName.includes(substring)
            )
          );
          if (isNonEmptyArray(unknownTargetsSubstrings2)) {
            logger.errorTemplate(
              unknownTargetsSubstrings(
                parseResult.elmWatchJsonPath,
                knownTargets,
                unknownTargetsSubstrings2
              )
            );
            return { tag: "Exit", exitCode: 1 };
          }
          const elmWatchStuffDir = {
            tag: "ElmWatchStuffDir",
            theElmWatchStuffDir: absolutePathFromString(
              absoluteDirname(parseResult.elmWatchJsonPath.theElmWatchJsonPath),
              "elm-stuff",
              "elm-watch"
            )
          };
          const elmWatchStuffJsonPath = {
            tag: "ElmWatchStuffJsonPath",
            theElmWatchStuffJsonPath: absolutePathFromString(
              elmWatchStuffDir.theElmWatchStuffDir,
              "stuff.json"
            )
          };
          const elmWatchStuffJsonParseResult = runMode === "hot" ? readAndParse2(elmWatchStuffJsonPath) : void 0;
          switch (elmWatchStuffJsonParseResult?.tag) {
            case "ElmWatchStuffJsonReadAsJsonError":
              logger.errorTemplate(
                readElmWatchStuffJsonAsJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.error
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case "ElmWatchStuffJsonDecodeError":
              logger.errorTemplate(
                decodeElmWatchStuffJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.error
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case void 0:
            case "Parsed":
            case "NoElmWatchStuffJson": {
              const elmWatchStuffJson2 = elmWatchStuffJsonParseResult?.tag === "Parsed" ? elmWatchStuffJsonParseResult.elmWatchStuffJson : void 0;
              const initProjectResult = initProject({
                env,
                getNow,
                compilationMode: parseArgsResult.compilationMode,
                elmWatchJsonPath: parseResult.elmWatchJsonPath,
                config: parseResult.config,
                enabledTargetsSubstrings: isNonEmptyArray(
                  parseArgsResult.targetsSubstrings
                ) ? parseArgsResult.targetsSubstrings : knownTargets,
                elmWatchStuffDir,
                elmWatchStuffJsonPath,
                elmWatchStuffJson: elmWatchStuffJson2
              });
              switch (initProjectResult.tag) {
                case "DuplicateOutputs":
                  logger.errorTemplate(
                    duplicateOutputs(
                      parseResult.elmWatchJsonPath,
                      initProjectResult.duplicates
                    )
                  );
                  return handleElmWatchJsonError(
                    logger,
                    getNow,
                    runMode,
                    parseResult.elmWatchJsonPath,
                    postprocessWorkerPool
                  );
                case "NoCommonRoot":
                  logger.errorTemplate(
                    noCommonRoot(initProjectResult.paths)
                  );
                  return { tag: "Exit", exitCode: 1 };
                case "Project": {
                  const { project } = initProjectResult;
                  logger.debug("Project", projectToDebug(project));
                  switch (project.postprocess.tag) {
                    case "NoPostprocess":
                      break;
                    case "Postprocess":
                      if (project.postprocess.postprocessArray[0] === ELM_WATCH_NODE) {
                        postprocessWorkerPool.getOrCreateAvailableWorker();
                      }
                      break;
                  }
                  switch (runMode) {
                    case "make": {
                      const result = await run2(
                        env,
                        logger,
                        getNow,
                        project,
                        postprocessWorkerPool
                      );
                      switch (result.tag) {
                        case "Error":
                          return { tag: "Exit", exitCode: 1 };
                        case "Success":
                          return { tag: "Exit", exitCode: 0 };
                      }
                    }
                    case "hot": {
                      const result = await run(
                        env,
                        logger,
                        getNow,
                        restartReasons,
                        postprocessWorkerPool,
                        webSocketState,
                        project,
                        config.port !== void 0 ? { tag: "PortFromConfig", port: config.port } : elmWatchStuffJson2 !== void 0 ? {
                          tag: "PersistedPort",
                          port: elmWatchStuffJson2.port
                        } : { tag: "NoPort" },
                        hotKillManager
                      );
                      switch (result.tag) {
                        case "ExitOnHandledFatalError":
                          logger.errorTemplate(result.errorTemplate);
                          return { tag: "Exit", exitCode: 1 };
                        case "ExitOnIdle":
                          return {
                            tag: "Exit",
                            exitCode: result.reason === "CtrlCPressedOrStdinEnd" ? 0 : 1
                          };
                        case "Restart":
                          return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
async function handleElmWatchJsonError(logger, getNow, runMode, elmWatchJsonPath, postprocessWorkerPool) {
  switch (runMode) {
    case "make":
      return { tag: "Exit", exitCode: 1 };
    case "hot": {
      logger.write("");
      printNumErrors(logger, 1);
      const elmWatchJsonEvent = await watchElmWatchJsonOnce(
        getNow,
        elmWatchJsonPath
      );
      logger.clearScreen();
      return {
        tag: "Restart",
        restartReasons: [{ ...elmWatchJsonEvent, affectsAnyTarget: true }],
        postprocessWorkerPool,
        webSocketState: void 0
      };
    }
  }
}

// src/index.ts
async function elmWatchCli(args, {
  cwd: cwdString,
  env,
  stdin,
  stdout,
  stderr,
  logDebug,
  hotKillManager = { kill: void 0 }
}) {
  const getNow = () => new Date();
  const logger = makeLogger({
    env,
    getNow,
    stdin,
    stdout,
    stderr,
    logDebug
  });
  const cwd = {
    tag: "Cwd",
    path: absolutePathFromString(
      { tag: "AbsolutePath", absolutePath: process.cwd() },
      cwdString
    )
  };
  const isHelp = args.some(
    (arg) => arg === "-h" || arg === "-help" || arg === "--help"
  );
  if (isHelp) {
    logger.write(render(logger.config));
    return 0;
  }
  const restArgs = args.slice(1).map((arg) => ({ tag: "CliArg", theArg: arg }));
  switch (args[0]) {
    case void 0:
    case "help":
      logger.write(render(logger.config));
      return 0;
    case "init":
      return init(cwd, logger, restArgs);
    case "make":
    case "hot": {
      const runMode = args[0];
      return new Promise((resolve3, reject) => {
        const doIt = async () => {
          let result;
          do {
            result = await run3(
              cwd,
              env,
              logger,
              getNow,
              runMode,
              restArgs,
              result === void 0 ? [] : result.restartReasons,
              result === void 0 ? new PostprocessWorkerPool(reject) : result.postprocessWorkerPool,
              result === void 0 ? void 0 : result.webSocketState,
              hotKillManager
            );
          } while (result.tag === "Restart");
          switch (result.tag) {
            case "Exit":
              return result.exitCode;
          }
        };
        doIt().then(resolve3).catch(reject);
      });
    }
    default:
      logger.write(`Unknown command: ${args[0]}`);
      return 1;
  }
}
if (require.main === module) {
  process.title = "elm-watch";
  elmWatchCli(process.argv.slice(2), {
    cwd: process.cwd(),
    env: process.env,
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    logDebug: (message) => process.stderr.write(`${message}
`)
  }).then((exitCode) => {
    process.exitCode = exitCode;
    if (process.stdin.setRawMode !== void 0) {
      process.stdin.setRawMode(false);
    }
    if (process.stdout.isTTY) {
      process.stdout.write(
        "Exiting elm-watch. Press ctrl+c (again) to force."
      );
      process.once("exit", () => {
        process.stdout.cursorTo(0);
        process.stdout.clearLine(0);
      });
    }
  }).catch((error) => {
    process.stderr.write(
      `Unexpected error:
${unknownErrorToString(error)}
`
    );
    process.exit(1);
  });
}